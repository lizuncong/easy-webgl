{"version":3,"file":"static/js/A024.73b2a92c.chunk.js","mappings":"yJAOE,QAJA,WACE,OAAOA,EAAAA,EAAAA,KAACC,EAAAA,EAAQ,CAACC,OAAQ,oqGAC3B,C","sources":["dynamic/pages/属性和缓冲/通过缓冲传递坐标和颜色值.jsx"],"sourcesContent":["import React from \"react\";\n  import MarkDown from \"@/components/markdown\";\n  \n  function Index() {\n    return <MarkDown srcDoc={\"## 使用同一个缓冲传递坐标和颜色值\\n\\n缓冲中不仅可以存储坐标数据，还可以存储颜色，法向量坐标等数据。我们通过一个demo实践一下，如何利用缓冲同时存储一个点的坐标和颜色值。\\n\\n下面的代码中，positions每5个数字存储一个点的坐标和颜色数据，其中前两个数字表示坐标，后面三个数字表示这个点的颜色值。\\n\\n\\n```js\\nconst canvas = document.getElementById('webgl')\\nconst gl = canvas.getContext('webgl')\\nconst vertexShaderSource1 = `\\n  attribute vec2 a_position;\\n  attribute vec3 a_color;\\n  varying vec3 v_color;\\n  void main(){\\n      v_color = a_color;\\n      gl_PointSize = 10.0;\\n      gl_Position = vec4(a_position, 0.0, 1.0);\\n  }\\n`\\nconst fragmentShaderSource1 = `\\n  precision mediump float;\\n  varying vec3 v_color;\\n  void main(){\\n      gl_FragColor = vec4(v_color, 1.0);\\n  }\\n`\\nconst program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1)\\n\\nconst positionLocation1 = gl.getAttribLocation(program1, 'a_position')\\nconst colorPosition = gl.getAttribLocation(program1, 'a_color')\\n\\nlet positions = [\\n  // x y  r g b 前面两个代表坐标，后面三个代表颜色rgb的值\\n  -0.5, 0.0, 1.0, 0.0, 0.0,\\n  0.5, 0.0, 0.0, 1.0, 0.0,\\n  0.0, 0.8, 0.0, 0.0, 1.0\\n]\\npositions = new Float32Array(positions)\\nconst FSIZE = positions.BYTES_PER_ELEMENT // 4\\n\\nconst positionBuffer = gl.createBuffer();\\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\\ngl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW)\\n\\n// 设置属性positionLocation1的一系列状态，告诉它应该怎么从缓冲中读取数据\\n// 定义点的信息\\ngl.vertexAttribPointer(\\n  positionLocation1,\\n  2, // size，attribute变量的长度(vec2)\\n  gl.FLOAT, // type, buffer的数据类型\\n  false,\\n  5 * FSIZE, // 每个点的信息所占的bytes\\n  0\\n);\\ngl.vertexAttribPointer(\\n  colorPosition,\\n  3, // size，attribute变量的长度(vec3)\\n  gl.FLOAT,\\n  false,\\n  5 * FSIZE,\\n  2 * FSIZE\\n);\\n\\n// 告诉webgl，属性positionLocation1应该从缓冲中读取数据，而不是从attributeValues中读取数据\\ngl.enableVertexAttribArray(positionLocation1);\\ngl.enableVertexAttribArray(colorPosition);\\n\\ngl.clearColor(0, 0, 0, 0)\\ngl.clear(gl.COLOR_BUFFER_BIT);\\n\\ngl.useProgram(program1)\\n// 告诉webgl绘制3个点\\ngl.drawArrays(gl.POINTS, 0, 3)\\ngl.drawArrays(gl.TRIANGLES, 0, 3);\\n```\\n\\n\\n结果如下：\\n\\n![image](../../easy-webgl/attri_04.jpg)\\n\\n\\n\"} />;\n  }\n  \n  export default Index;"],"names":["_jsx","MarkDown","srcDoc"],"sourceRoot":""}