{"version":3,"file":"static/js/A010.236b95c7.chunk.js","mappings":"0JAOE,QAJA,WACE,OAAOA,EAAAA,EAAAA,KAACC,EAAAA,EAAQ,CAACC,OAAQ,kzIAC3B,C","sources":["dynamic/pages/属性和缓冲/属性的两种赋值方式.jsx"],"sourcesContent":["import React from \"react\";\n  import MarkDown from \"@/components/markdown\";\n  \n  function Index() {\n    return <MarkDown srcDoc={\"## 前言\\n\\nWebGL代码由一对着色程序组成，即`顶点着色器`和`片段着色器`。着色器代码都是在GPU中运行，它们所需的任何数据都需要发送到GPU，在GPU中读取。着色器可以通过下面4种方法获取数据：\\n\\n- 属性(Attributes)和缓冲。属性仅适用于顶点着色器\\n- 全局变量（Uniforms）。在一次绘制中对所有顶点或者像素保持一致值。适用于顶点着色器和片段着色器\\n- 纹理（Textures）。从像素或纹理元素中获取的数据。适用于顶点着色器和片段着色器\\n- 可变量（Varyings）。顶点着色器给片段着色器传值的一种方式。给顶点着色器中可变量设置的值，会作为参考值进行内插，在绘制像素时传给片段着色器的可变量\\n\\n本篇文章主要讲的是`属性`和`缓冲`。`缓冲`是发送到GPU的一些二进制数据序列，是GPU中的一块内存区域，可以存储任何数据。`属性`用来指明怎么从缓冲中获取所需数据并将它提供给顶点着色器。\\n\\n本节使用到的html代码如下：\\n```html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n  <meta charset=\\\"utf-8\\\" />\\n  <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\" />\\n  <meta name=\\\"theme-color\\\" content=\\\"#000000\\\" />\\n  <meta name=\\\"description\\\" content=\\\"WebGL\\\" />\\n  <title>WebGL</title>\\n  <style>\\n    body {\\n      margin: 20px;\\n    }\\n    #webgl {\\n      width: 500px;\\n      height: 500px;\\n    }\\n    .container {\\n      font-size: 0;\\n      display: inline-block;\\n      border: 1px solid black;\\n      background: red;\\n    }\\n  </style>\\n</head>\\n<body>\\n  <div class=\\\"container\\\">\\n    <canvas width=\\\"500\\\" height=\\\"500\\\" id=\\\"webgl\\\">你的浏览器不支持canvas</canvas>\\n  </div>\\n  <script src=\\\"./initShaders.js\\\"></script>\\n  <script src=\\\"./index.js\\\"></script>\\n</body>\\n</html>\\n```\\n\\n## 属性\\n\\n在 WebGL 中，属性是顶点着色器的输入，可以直接给属性赋值，也可以从缓冲中获取数据。有两种方式可以给属性赋值：\\n\\n- `WebGLRenderingContext.vertexAttrib[1234]f[v]()`。这种方式不常用，了解一下即可\\n- 缓冲。常用的方式\\n\\n下面的代码通过gl.vertexAttrib2f给属性赋值绘制一个点：\\n\\n```js\\nconst canvas = document.getElementById('webgl')\\nconst gl = canvas.getContext('webgl')\\nconst vertexShaderSource = `\\n    attribute vec2 a_position1;\\n    void main() {\\n      gl_Position = vec4(a_position1, 0, 1);\\n      gl_PointSize = 10.0;\\n    }\\n`\\nconst fragmentShaderSource = `\\n    precision mediump float;\\n    void main() {\\n      gl_FragColor = vec4(1,0,0.5,1);\\n    }\\n`\\nconst program = initShaders(gl, vertexShaderSource, fragmentShaderSource)\\nconst positionLocation1 = gl.getAttribLocation(program, 'a_position1')\\n\\ngl.clearColor(0, 0, 0, 0)\\ngl.clear(gl.COLOR_BUFFER_BIT);\\n\\ngl.useProgram(program)\\ngl.vertexAttrib2f(positionLocation1, 0.5, 0.5)\\n\\ngl.drawArrays(gl.POINTS, 0, 1)\\n```\\n\\n结果如下，在(0.5,0.5)坐标上绘制了一个10 * 10大小的点\\n\"} />;\n  }\n  \n  export default Index;"],"names":["_jsx","MarkDown","srcDoc"],"sourceRoot":""}