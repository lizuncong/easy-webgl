{"version":3,"file":"static/js/A002.0afe27a6.chunk.js","mappings":"yJAOE,QAJA,WACE,OAAOA,EAAAA,EAAAA,KAACC,EAAAA,EAAQ,CAACC,OAAQ,qsgBAC3B,C","sources":["dynamic/pages/属性和缓冲/属性的两种赋值方式.jsx"],"sourcesContent":["import React from \"react\";\n  import MarkDown from \"@/components/markdown\";\n  \n  function Index() {\n    return <MarkDown srcDoc={\"## 前言\\n\\nWebGL代码由一对着色程序组成，即`顶点着色器`和`片段着色器`。着色器代码都是在GPU中运行，它们所需的任何数据都需要发送到GPU，在GPU中读取。着色器可以通过下面4种方法获取数据：\\n\\n- 属性(Attributes)和缓冲。属性仅适用于顶点着色器\\n- 全局变量（Uniforms）。在一次绘制中对所有顶点或者像素保持一致值。适用于顶点着色器和片段着色器\\n- 纹理（Textures）。从像素或纹理元素中获取的数据。适用于顶点着色器和片段着色器\\n- 可变量（Varyings）。顶点着色器给片段着色器传值的一种方式。给顶点着色器中可变量设置的值，会作为参考值进行内插，在绘制像素时传给片段着色器的可变量\\n\\n`缓冲`是发送到GPU的一些二进制数据序列，是GPU中的一块内存区域，可以存储任何数据。`属性`用来指明怎么从缓冲中获取所需数据并将它提供给顶点着色器。\\n\\n本节主要讲属性以及属性的两种赋值方式。本节使用到的html代码如下：\\n```html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n  <meta charset=\\\"utf-8\\\" />\\n  <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\" />\\n  <meta name=\\\"theme-color\\\" content=\\\"#000000\\\" />\\n  <meta name=\\\"description\\\" content=\\\"WebGL\\\" />\\n  <title>WebGL</title>\\n  <style>\\n    body {\\n      margin: 20px;\\n    }\\n    #webgl {\\n      width: 500px;\\n      height: 500px;\\n    }\\n    .container {\\n      font-size: 0;\\n      display: inline-block;\\n      border: 1px solid black;\\n      background: red;\\n    }\\n  </style>\\n</head>\\n<body>\\n  <div class=\\\"container\\\">\\n    <canvas width=\\\"500\\\" height=\\\"500\\\" id=\\\"webgl\\\">你的浏览器不支持canvas</canvas>\\n  </div>\\n  <script src=\\\"./initShaders.js\\\"></script>\\n  <script src=\\\"./index.js\\\"></script>\\n</body>\\n</html>\\n```\\n\\n## 属性\\n\\n在 WebGL 中，属性是顶点着色器的输入，可以直接给属性赋值，也可以从缓冲中获取数据。有两种方式可以给属性赋值：\\n\\n- `WebGLRenderingContext.vertexAttrib[1234]f[v]()`。这种方式不常用，了解一下即可\\n- 缓冲。常用的方式\\n\\n\\n### 使用gl.vertexAttrib[1234]f[v]赋值\\n下面的代码通过gl.vertexAttrib2f给属性赋值绘制一个点：\\n\\n```js\\nconst canvas = document.getElementById('webgl')\\nconst gl = canvas.getContext('webgl')\\nconst vertexShaderSource = `\\n    attribute vec2 a_position1;\\n    void main() {\\n      gl_Position = vec4(a_position1, 0, 1);\\n      gl_PointSize = 10.0;\\n    }\\n`\\nconst fragmentShaderSource = `\\n    precision mediump float;\\n    void main() {\\n      gl_FragColor = vec4(1,0,0.5,1);\\n    }\\n`\\nconst program = initShaders(gl, vertexShaderSource, fragmentShaderSource)\\nconst positionLocation1 = gl.getAttribLocation(program, 'a_position1')\\n\\ngl.clearColor(0, 0, 0, 0)\\ngl.clear(gl.COLOR_BUFFER_BIT);\\n\\ngl.useProgram(program)\\ngl.vertexAttrib2f(positionLocation1, 0.5, 0.5)\\n\\ngl.drawArrays(gl.POINTS, 0, 1)\\n```\\n\\n结果如下，在(0.5,0.5)坐标上绘制了一个10 * 10大小的点\\n\\n![image](../../easy-webgl/attri_01.jpg)\\n\\n\\n## 缓冲\\n\\n缓冲区对象是 WebGL系统中的一块内存区域，我们可以一次性地向缓冲区对象中填充大量的顶点数据，供顶点着色器使用。\\n\\n\\n### 为什么需要缓冲？\\n\\n在解释这个问题前，我们先来看下如何通过`gl.vertexAttrib[1234]f[v]()`的方式绘制多个点。\\n\\n```js\\n  const canvas = document.getElementById('webgl')\\n  const gl = canvas.getContext('webgl')\\n  const vertexShaderSource1 = `\\n    attribute vec2 a_position1;\\n    void main() {\\n      gl_Position = vec4(a_position1, 0, 1);\\n      gl_PointSize = 10.0;\\n    }\\n  `\\n  const fragmentShaderSource1 = `\\n    precision mediump float;\\n    void main() {\\n      gl_FragColor = vec4(1,0,0.5,1);\\n    }\\n  `\\n  const program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1)\\n\\n  const positionLocation1 = gl.getAttribLocation(program1, 'a_position1')\\n\\n  const positions = [\\n    0.0, 0.0,\\n    0.5, 0.5,\\n    0.5, 0.0,\\n  ]\\n\\n  gl.clearColor(0, 0, 0, 0)\\n  gl.clear(gl.COLOR_BUFFER_BIT);\\n  gl.useProgram(program1)\\n\\n  for(let i = 0; i < 6;i=i+2){\\n    console.log(i)\\n    const x = positions[i]\\n    const y = positions[i+1]\\n    gl.vertexAttrib2f(positionLocation1, x, y)\\n\\n    gl.drawArrays(gl.POINTS, 0, 1)\\n  }\\n```\\n\\n结果如下：\\n\\n![image](../../easy-webgl/attri_02.jpg)\\n\\n在上面的代码中，我们绘制三个点，for循环里调用了三次`gl.vertexAttrib2f`给属性传值。这意味着CPU和GPU至少有三次通信的过程。如果绘制的点有n个，就需要n次通信传值，效率低下，存在较大的性能瓶颈。\\n\\n因此，更好的做法是，我们一次性往GPU发送这些顶点数据，并通过设置属性的一些状态，告诉GPU怎么读取这些顶点数据。\\n\\n### 如何给缓冲传值\\n\\n使用缓冲区对象向顶点着色器传入多个顶点的数据，需要遵循以下五个步骤。处理其他对象，比如纹理对象、帧缓冲区对象时的步骤也比较类似：\\n\\n- gl.createBuffer。创建缓冲区对象。\\n- gl.bindBuffer。绑定缓冲区对象。\\n- gl.bufferData。将数据写入缓冲区对象。\\n- gl.vertexAttribPointer。将缓冲区对象分配给一个属性(attribute)变量，并告诉属性应该怎么读取缓冲中的数据\\n- gl.enableVertexAttribArray。开启属性(attribute)变量。实际上就是告诉webgl，这个属性应该从缓冲中读取数据，如果调用gl.disableVertexAttribArray关闭属性，那属性就会从attributeValues中读取值。\\n\\n也太繁琐了吧！不知道你是否有很多疑问，为什么要bindBuffer？为什么要enableVertexAttribArray？vertexAttribPointer是干什么的？\\n\\n别急，在介绍上面各个API前，我们先来看下如何使用缓冲绘制三个点：\\n\\n```js\\n  const canvas = document.getElementById('webgl')\\n  const gl = canvas.getContext('webgl')\\n  const vertexShaderSource1 = `\\n    attribute vec2 a_position1;\\n    void main() {\\n      gl_Position = vec4(a_position1, 0, 1);\\n      gl_PointSize = 10.0;\\n    }\\n  `\\n  const fragmentShaderSource1 = `\\n    precision mediump float;\\n    void main() {\\n      gl_FragColor = vec4(1,0,0.5,1);\\n    }\\n  `\\n  const program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1)\\n\\n  const positionLocation1 = gl.getAttribLocation(program1, 'a_position1')\\n\\n  const positions = [\\n    0.0, 0.0,\\n    0.5, 0.5,\\n    0.5, 0.0,\\n  ]\\n  const positionBuffer = gl.createBuffer();\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)\\n\\n  // 设置属性positionLocation1的一系列状态，告诉它应该怎么从缓冲中读取数据\\n  gl.vertexAttribPointer(\\n    positionLocation1, 2, gl.FLOAT, false, 0, 0)\\n\\n  // 告诉webgl，属性positionLocation1应该从缓冲中读取数据，而不是从attributeValues中读取数据\\n  gl.enableVertexAttribArray(positionLocation1);\\n\\n  gl.clearColor(0, 0, 0, 0)\\n  gl.clear(gl.COLOR_BUFFER_BIT);\\n\\n  gl.useProgram(program1)\\n  // 告诉webgl绘制三个点\\n  gl.drawArrays(gl.POINTS, 0, 3)\\n```\\n\\n\\n这次，我们调用gl.createBuffer在webgl中创建一个缓冲区对象，并调用gl.bufferData往缓冲区发送数据。然后调用gl.vertexAttribPointer告诉属性应该怎么读取值。\\n\\n那为什么使用缓冲需要这么繁琐的步骤呢？实际上，在webgl内部维护了一系列的全局状态，类似指针，比如gl.ARRAY\\\\_BUFFER就是用来操作缓冲。当调用gl.bindBuffer(gl.ARRAY\\\\_BUFFER, positionBuffer)时，实际上就是将全局的gl.ARRAY\\\\_BUFFER指向`positionBuffer`这个内存区域。后续对gl.ARRAY\\\\_BUFFER的操作都是对`positionBuffer`内存的操作，除非调用gl.bindBuffer重新绑定到其他内存区域。gl.bufferData(gl.ARRAY\\\\_BUFFER, new Float32Array(positions), gl.STATIC\\\\_DRAW)就是给`positionBuffer`内存设置数据。\\n\\ngl.bindBuffer伪代码如下：\\n\\n```js\\n// 伪代码\\ngl.bindBuffer = function(target, buffer) {\\n  switch (target) {\\n    case ARRAY_BUFFER:\\n      gl.arrayBuffer = buffer;\\n      break;\\n    case ELEMENT_ARRAY_BUFFER;\\n      gl.vertexArray.elementArrayBuffer = buffer;\\n      break;\\n  ...\\n};\\ngl.bufferData = function(target, data, type) {\\n  gl.arrayBuffer = data;\\n  ...\\n};\\n```\\n\\n因此，调用gl.bufferData给缓冲区传数据前，一定要先确保已经调用gl.bindBuffer绑定了正确的缓冲区。\\n\\ngl.vertexAttribPointer 用来设置几乎所有其它属性设置。它实现起来像这样：\\n\\n```js\\n// 伪代码\\ngl.vertexAttribPointer = function(location, size, type, normalize, stride, offset) {\\n  const attrib = gl.vertexArray.attributes[location];\\n  attrib.size = size;\\n  attrib.type = type;\\n  attrib.normalize = normalize;\\n  attrib.stride = stride ? stride : sizeof(type) * size;\\n  attrib.offset = offset;\\n  attrib.buffer = gl.arrayBuffer;  // !!!! <-----\\n};\\n```\\n\\n注意，当我们调用 gl.vertexAttribPointer 时，attrib.buffer 会被设置成当前 gl.arrayBuffer 的值。属性就会自动绑定到缓冲区。因此，在调用gl.vertexAttribPointer设置属性的状态前，务必确保已经调用了gl.bindBuffer绑定了正确的缓冲区。\\n\\ngl.enableVertexAttribArray伪代码如下：\\n\\n```js\\n// 伪代码\\ngl.enableVertexAttribArray = function(location) {\\n  const attrib = gl.vertexArray.attributes[location];\\n  attrib.enable = true;\\n};\\n \\ngl.disableVertexAttribArray = function(location) {\\n  const attrib = gl.vertexArray.attributes[location];\\n  attrib.enable = false;\\n};\\n```\\n\\nattrib.enable设置成true，告诉webgl属性需要从缓冲中读取数据。设置成false，告诉wegbl属性需要从attributeValues中读取数据。\\n\\n下面可以通过一个例子来验证一下gl.enableVertexAttribArray的作用。\\n\\n```js\\n  const canvas = document.getElementById('webgl')\\n  const gl = canvas.getContext('webgl')\\n  const vertexShaderSource1 = `\\n    attribute vec2 a_position1;\\n    void main() {\\n      gl_Position = vec4(a_position1, 0, 1);\\n      gl_PointSize = 10.0;\\n    }\\n  `\\n  const fragmentShaderSource1 = `\\n    precision mediump float;\\n    void main() {\\n      gl_FragColor = vec4(1,0,0.5,1);\\n    }\\n  `\\n  const program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1)\\n\\n  const positionLocation1 = gl.getAttribLocation(program1, 'a_position1')\\n\\n  const positions = [\\n    0.0, 0.0,\\n  ]\\n  const positionBuffer = gl.createBuffer();\\n  console.log('position...',positionBuffer)\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)\\n\\n  // 设置属性positionLocation1的一系列状态，告诉它应该怎么从缓冲中读取数据\\n  gl.vertexAttribPointer(\\n    positionLocation1, 2, gl.FLOAT, false, 0, 0)\\n\\n  // 告诉webgl，属性positionLocation1应该从缓冲中读取数据，而不是从attributeValues中读取数据\\n  gl.enableVertexAttribArray(positionLocation1);\\n  // 当调用enableVertexAttribArray告诉属性从缓冲读取数据，即使再调用vertexAttrib2f设置属性的值，也没用\\n  // 属性依旧会从缓冲中读取数据\\n  gl.vertexAttrib2f(positionLocation1, 0.5, 0.5)\\n  gl.clearColor(0, 0, 0, 0)\\n  gl.clear(gl.COLOR_BUFFER_BIT);\\n\\n  gl.useProgram(program1)\\n  // 告诉webgl绘制1个点\\n  gl.drawArrays(gl.POINTS, 0, 1)\\n\\n  // 告诉属性不要再从缓冲中读取数据\\n  gl.disableVertexAttribArray(positionLocation1);\\n  gl.drawArrays(gl.POINTS, 0, 1)\\n```\\n\\n我们首先使用缓冲中的数据在(0.0,0.0)处绘制一个点。然后调用gl.disableVertexAttribArray(positionLocation1)告诉WebGL不要从缓冲中读取数据，因此第二次调用gl.drawArrays时，WebGL使用gl.attributeValues中的值，即(0.5,0.5)。\\n\\n\\n![image](../../easy-webgl/attri_03.jpg)\\n\"} />;\n  }\n  \n  export default Index;"],"names":["_jsx","MarkDown","srcDoc"],"sourceRoot":""}