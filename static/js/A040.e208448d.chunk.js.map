{"version":3,"file":"static/js/A040.e208448d.chunk.js","mappings":"0JAOE,QAJA,WACE,OAAOA,EAAAA,EAAAA,KAACC,EAAAA,EAAQ,CAACC,OAAQ,opcAC3B,C","sources":["dynamic/pages/纹理/为什么纹理是颠倒的.jsx"],"sourcesContent":["import React from \"react\";\n  import MarkDown from \"@/components/markdown\";\n  \n  function Index() {\n    return <MarkDown srcDoc={\"## 为什么WebGL纹理是上下颠倒的\\n\\n## 前言\\n在WebGL中绘制图片需要使用`纹理数据`。和WebGL渲染时需要裁剪空间坐标相似，渲染纹理时需要纹理坐标，而不是像素坐标。`纹理数据`的类型非常丰富，比如图像数据，JS生成的数据纹理等。本节所说的纹理上下颠倒，实际上说的是WebGL在将图像纹理数据绘制到WebGL画布时，画布的图片是上下颠倒的。本节我们就深入剖析这个问题。\\n\\n在此之前，我们先简单了解一下纹理的工作原理和纹理数据类型。\\n\\n\\n### 纹理数据类型\\nWebGL纹理数据的类型非常丰富，涵盖图像、程序生成的数据、特殊效果映射等。**WebGL纹理数据的底层通常是数组形式的**。以下是常见的纹理数据分类及其特点：\\n- **1.基础图像数据：**通过图像文件(如PNG、JPEG等)加载的2D纹理，是最常见的类型。图像纹理的使用可以看这篇文章[WebGL图像处理](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-image-processing.html)。图像类纹理加载后，会解码为像素值的数组，每个元素表示一个像素的颜色或透明度，再通过gl.texImage2D上传到GPU。WebGL会将数组转换为纹理的内部格式（如gl.RGBA8、gl.RGBA32F）。\\n- **2.程序生成的数据纹理：**无需外部图像，直接通过JS生成的数据纹理。数据纹理直接使用数值数组（如Float32Array、Uint8Array）生成纹理并上传到GPU。数据纹理的使用可以看这篇文章[WebGL数据纹理](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-data-textures.html)\\n\\n\\n### 纹理的工作原理\\n- **1.加载与创建：**使用gl.texImage2D将`纹理数据`上传到GPU\\n- **2.纹理坐标映射：**模型顶点通过(u,v)纹理坐标(范围[0,1]或[1,0])绑定到纹理\\n- **3.着色器采样：**在片段着色器中，通过texture2D函数获取像素值，并计算最终颜色。\\n\\n\\ngl.texImage2D是OpenGL/WebGL中用于将2D纹理数据上传到GPU的核心函数。它的底层操作会根据传入数据的类型（图像纹理或数据纹理）有不同的处理逻辑。无论数据类型如何，gl.texImage2D的最终目标是将数据存储到GPU的纹理内存中，供着色器采样。其核心步骤包括：\\n\\n- 数据格式转换：将CPU侧的数组或图像数据转换为GPU可识别的内部格式（如 GL_RGBA8、GL_RGBA32F）。\\n- 内存分配：在GPU上为纹理分配存储空间。\\n- 数据拷贝：将CPU数据复制到GPU内存。\\n- MIPMAP生成（可选）：根据参数自动生成多级渐远纹理（MIPMAP）。\\n\\n> 因此，不管是图像纹理数据还是数据纹理，最终在GPU纹理内存中都是类数组的形式存储\\n\\n\\n\\n### 纹理坐标\\n纹理是通过“纹理坐标”来引用的，纹理坐标0.0到1.0对应纹理从左到右，0.0到1.0对应第一个像素所在行到最后一行。上下在纹理坐标空间中是没有意义的，主要是依据传递给WebGL的纹理数据，纹理数据的开头对应纹理坐标(0,0)，结尾对应纹理坐标(1,1)\\n\\n​纹理坐标是将纹理映射到三维物体表面的关键机制。纹理坐标定义了每个三维顶点在纹理图像中的对应位置，告诉 WebGL：“这个顶点应该显示纹理图像的哪个部分”\\n\\n下面通过例子来演示不同类型纹理数据，如何通过纹理坐标引用。我们将在画布(0, 0)到(0.5, 0.5)处使用纹理绘制矩形。\\n\\n![image](../../easy-webgl/coor_01.png)\\n\\n对应的矩形的顶点坐标为：\\n```js\\nconst rectX = 0.0, rectY = 0.5, rectWidth = 0.5, rectHeight = 0.5\\nlet verticesInfo = [\\n    rectX, rectY,\\n    rectX + rectWidth, rectY,\\n    rectX, rectY - rectHeight,\\n    rectX, rectY - rectHeight,\\n    rectX + rectWidth, rectY,\\n    rectX + rectWidth, rectY - rectHeight,\\n]\\n```\\n\\n\\n#### 数据纹理\\n我们使用下面 `4 x 4` 像素的数据纹理填充上面的矩形\\n```js\\n  // 用 4x4 的像素填充纹理\\n  const level = 0;\\n  const internalFormat = gl.RGBA;\\n  const width = 4;\\n  const height = 4;\\n  const border = 0;\\n  const format = gl.RGBA;\\n  const type = gl.UNSIGNED_BYTE;\\n  const data = new Uint8Array([\\n    255, 0, 0, 255, // 红\\n    0, 255, 0, 255, // 绿\\n    0, 0, 255, 255, // 蓝\\n    255, 255, 0, 255, // 黄\\n\\n    255, 0, 255, 255, // 品红色\\n    0, 255, 255, 255, // 青色\\n    105, 255, 105, 255,   // 青柠绿\\n    0, 0, 0, 255, // 黑色\\n\\n\\n    255, 165, 0, 255,    // 橙色\\n    75, 32, 132, 255,    // 深紫色\\n    255, 218, 0, 255,    // 金色\\n    124, 252, 0,  255,   // 荧光绿\\n\\n    255, 20, 133, 255,      // 珊瑚色\\n    255, 182, 193, 255,   // 淡粉红\\n    138, 43, 238, 255,    // 魔法蓝\\n    255, 255, 255, 255,     // 白色\\n  ]);\\n  gl.texImage2D(\\n    gl.TEXTURE_2D,\\n    level,\\n    internalFormat,\\n    width,\\n    height,\\n    border,\\n    format,\\n    type,\\n    data\\n  );\\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\\n\\n```\\n\\n如果用纹理坐标表示数据纹理，那么数据纹理的第一个颜色(即红色)像素位于左下角，最后一个颜色(即白色)香色位于右上角，如下图所示：\\n\\n![image](../../easy-webgl/coor_02.jpg)\\n\\n现在我们用这个数据纹理填充上面的矩形，我们给WebGL提供的纹理坐标如下：\\n```js\\n  const x = 0, y = 0, textWidth = 1.0, textHeight = 1.0;\\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\\n    x, y + textHeight,\\n    x + textWidth, y + textHeight,\\n    x, y,\\n    x, y,\\n    x + textWidth, y + textHeight,\\n    x + textWidth, y\\n  ]), gl.STATIC_DRAW);\\n```\\n对应关系见下图绿色数字，图中绿色数字表示传输给WebGL的顶点坐标和纹理坐标的顺序。\\n\\n![image](../../easy-webgl/coor_06.jpg)\\n\\n绘制结果如下：\\n\\n![image](../../easy-webgl/coor_03.jpg)\\n\\n如果我们只需要用中间四个像素填充矩形，即下图红框中四个像素\\n\\n![image](../../easy-webgl/coor_04.jpg)\\n\\n只需要修改上面的代码\\n\\n```js\\nconst x = 0.25, y = 0.25, textWidth = 0.5, textHeight = 0.5;\\n// const x = 0, y = 0, textWidth = 1.0, textHeight = 1.0;\\n```\\n\\n绘制结果如下\\n\\n![image](../../easy-webgl/coor_05.jpg)\\n\\n\\n完整代码如下：\\n```js\\nconst main = () => {\\n  const canvas = document.getElementById('webgl')\\n  const gl = canvas.getContext('webgl2')\\n  const vertexShaderSource1 = `\\n    attribute vec2 a_texCoord;\\n    attribute vec2 a_position;\\n    varying vec2 v_texCoord;\\n    void main(){\\n        gl_PointSize = 10.0;\\n        gl_Position = vec4(a_position, 0.0, 1.0);\\n        // 将纹理坐标传给片段着色器\\n        // GPU会在点之间进行插值\\n        v_texCoord = a_texCoord;\\n    }\\n  `\\n  const fragmentShaderSource1 = `\\n    precision mediump float;\\n    uniform sampler2D u_image;\\n    // 从顶点着色器传入的纹理坐标\\n    varying vec2 v_texCoord;\\n    void main(){\\n      // 在纹理上寻找对应颜色值\\n      gl_FragColor = texture2D(u_image, v_texCoord);\\n    }\\n  `\\n  const program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1)\\n  const positionLocation1 = gl.getAttribLocation(program1, 'a_position')\\n  const texCoordLocation = gl.getAttribLocation(program1, \\\"a_texCoord\\\");\\n\\n  // 给矩形提供纹理坐标\\n  const texCoordBuffer = gl.createBuffer();\\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\\n  const x = 0.25, y = 0.25, textWidth = 0.5, textHeight = 0.5;\\n  // const x = 0, y = 0, textWidth = 1.0, textHeight = 1.0;\\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\\n    x, y + textHeight,\\n    x + textWidth, y + textHeight,\\n    x, y,\\n    x, y,\\n    x + textWidth, y + textHeight,\\n    x + textWidth, y\\n  ]), gl.STATIC_DRAW);\\n  gl.enableVertexAttribArray(texCoordLocation);\\n  gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\\n\\n  const rectX = 0.0, rectY = 0.5, rectWidth = 0.5, rectHeight = 0.5\\n  let verticesInfo = [\\n    rectX, rectY,\\n    rectX + rectWidth, rectY,\\n    rectX, rectY - rectHeight,\\n    rectX, rectY - rectHeight,\\n    rectX + rectWidth, rectY,\\n    rectX + rectWidth, rectY - rectHeight,\\n  ]\\n \\n  verticesInfo = new Float32Array(verticesInfo);\\n\\n  const vertexBuffer = gl.createBuffer();\\n  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\\n  gl.bufferData(gl.ARRAY_BUFFER, verticesInfo, gl.STATIC_DRAW);\\n\\n  gl.vertexAttribPointer(positionLocation1, 2, gl.FLOAT, false, 8, 0);\\n\\n  gl.enableVertexAttribArray(positionLocation1);\\n\\n  // 创建纹理\\n  var texture = gl.createTexture();\\n  gl.bindTexture(gl.TEXTURE_2D, texture);\\n\\n  // 用 4x4 的像素填充纹理\\n  const level = 0;\\n  const internalFormat = gl.RGBA;\\n  const width = 4;\\n  const height = 4;\\n  const border = 0;\\n  const format = gl.RGBA;\\n  const type = gl.UNSIGNED_BYTE;\\n  const data = new Uint8Array([\\n    255, 0, 0, 255, // 红\\n    0, 255, 0, 255, // 绿\\n    0, 0, 255, 255, // 蓝\\n    255, 255, 0, 255, // 黄\\n\\n    255, 0, 255, 255, // 品红色\\n    0, 255, 255, 255, // 青色\\n    105, 255, 105, 255,   // 青柠绿\\n    0, 0, 0, 255, // 黑色\\n\\n\\n    255, 165, 0, 255,    // 橙色\\n    75, 32, 132, 255,    // 深紫色\\n    255, 218, 0, 255,    // 金色\\n    124, 252, 0,  255,   // 荧光绿\\n\\n    255, 20, 133, 255,      // 珊瑚色\\n    255, 182, 193, 255,   // 淡粉红\\n    138, 43, 238, 255,    // 魔法蓝\\n    255, 255, 255, 255,     // 白色\\n  ]);\\n  gl.texImage2D(\\n    gl.TEXTURE_2D,\\n    level,\\n    internalFormat,\\n    width,\\n    height,\\n    border,\\n    format,\\n    type,\\n    data\\n  );\\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\\n\\n\\n  gl.clearColor(0, 0, 0, 0)\\n\\n  gl.clear(gl.COLOR_BUFFER_BIT);\\n\\n  gl.useProgram(program1)\\n\\n\\n  gl.drawArrays(gl.TRIANGLES, 0, 6)\\n\\n}\\n\\nmain();\\n```\\n\\n至此，我们通过demo演示了数据纹理是如何通过纹理坐标填充三维物体表面的。\\n\\n#### 图像数据纹理\"} />;\n  }\n  \n  export default Index;"],"names":["_jsx","MarkDown","srcDoc"],"sourceRoot":""}