{"version":3,"file":"static/js/A044.bb629e0c.chunk.js","mappings":"0JAOE,QAJA,WACE,OAAOA,EAAAA,EAAAA,KAACC,EAAAA,EAAQ,CAACC,OAAQ,utJAC3B,C","sources":["dynamic/pages/纹理/纹理的简单使用.jsx"],"sourcesContent":["import React from \"react\";\n  import MarkDown from \"@/components/markdown\";\n  \n  function Index() {\n    return <MarkDown srcDoc={\"## WebGL 图像处理\\n\\n在 WebGL 中绘制图片需要使用纹理。和 WebGL 渲染时需要裁剪空间坐标相似，渲染纹理时需要纹理坐标，而不是像素坐标。无论纹理是什么尺寸，纹理坐标范围始终是 0.0 到 1.0。\\n\\n如下图所示，这里我们将右边猫的图片绘制到画布(0,0)到(0.5, 0.5)的区域\\n\\n![image](../../easy-webgl/texture_07.png)\\n\\n猫图片原图如下：\\n\\n![image](../../easy-webgl/cat.jpeg)\\n\\n矩形的坐标数据为：\\n\\n```js\\nconst rectX = 0.5,\\n  rectY = 0.5;\\nlet verticesInfo = [\\n  0.0,rectY,\\n  rectX,rectY,\\n  0,0,\\n  rectX,rectY,\\n  0,0,\\n  rectX,0,\\n];\\n```\\n\\n对应的图片纹理坐标为：\\n\\n```js\\nconst x = 1.0,\\n  y = 1.0;\\ngl.bufferData(\\n  gl.ARRAY_BUFFER,\\n  new Float32Array([\\n    0.0, 0.0, \\n    x, 0.0, \\n    0.0, y, \\n    x, 0.0, \\n    0.0, y, \\n    x, y\\n  ]),\\n  gl.STATIC_DRAW\\n);\\n```\\n\\n注意，矩形的坐标点顺序必须和纹理坐标顺序一致，不然绘制的图像显示就会有问题。\\n\\n结果如下：\\n\\n![image](../../easy-webgl/texture_08.jpg)\\n\\n完整代码如下：\\n\\n```js\\nconst main = (image) => {\\n  const canvas = document.getElementById(\\\"webgl\\\");\\n  const gl = canvas.getContext(\\\"webgl\\\");\\n  const vertexShaderSource1 = `\\n      attribute vec2 a_texCoord;\\n      attribute vec2 a_position;\\n      varying vec2 v_texCoord;\\n      void main(){\\n          gl_PointSize = 10.0;\\n          gl_Position = vec4(a_position, 0.0, 1.0);\\n          // 将纹理坐标传给片段着色器\\n          // GPU会在点之间进行插值\\n          v_texCoord = a_texCoord;\\n      }\\n    `;\\n  const fragmentShaderSource1 = `\\n      precision mediump float;\\n      uniform sampler2D u_image;\\n      // 从顶点着色器传入的纹理坐标\\n      varying vec2 v_texCoord;\\n      void main(){\\n        // 在纹理上寻找对应颜色值\\n        gl_FragColor = texture2D(u_image, v_texCoord);\\n      }\\n    `;\\n  const program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1);\\n  const positionLocation1 = gl.getAttribLocation(program1, \\\"a_position\\\");\\n  const texCoordLocation = gl.getAttribLocation(program1, \\\"a_texCoord\\\");\\n\\n  // 给矩形提供纹理坐标\\n  const texCoordBuffer = gl.createBuffer();\\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\\n  const x = 1.0,\\n    y = 1.0;\\n  gl.bufferData(\\n    gl.ARRAY_BUFFER,\\n    new Float32Array([\\n        0.0, 0.0, \\n        x, 0.0, \\n        0.0, y, \\n        x, 0.0, \\n        0.0, y, \\n        x, y\\n    ]),\\n    gl.STATIC_DRAW\\n  );\\n  gl.enableVertexAttribArray(texCoordLocation);\\n  gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\\n\\n  // 创建纹理\\n  var texture = gl.createTexture();\\n  gl.bindTexture(gl.TEXTURE_2D, texture);\\n\\n  // // 设置参数，让我们可以绘制任何尺寸的图像\\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\\n\\n  // 将图像上传到纹理\\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\n\\n  const rectX = 0.5,\\n    rectY = 0.5;\\n  let verticesInfo = [\\n    0.0,rectY,\\n    rectX,rectY,\\n    0,0,\\n    rectX,rectY,\\n    0,0,\\n    rectX,0,\\n  ];\\n  verticesInfo = new Float32Array(verticesInfo);\\n\\n  const vertexBuffer = gl.createBuffer();\\n  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\\n  gl.bufferData(gl.ARRAY_BUFFER, verticesInfo, gl.STATIC_DRAW);\\n\\n  gl.vertexAttribPointer(positionLocation1, 2, gl.FLOAT, false, 8, 0);\\n\\n  gl.clearColor(0, 0, 0, 0.1);\\n\\n  gl.clear(gl.COLOR_BUFFER_BIT);\\n\\n  gl.useProgram(program1);\\n\\n  gl.enableVertexAttribArray(positionLocation1);\\n\\n  gl.drawArrays(gl.TRIANGLES, 0, 6);\\n};\\n\\nconst image = new Image();\\nimage.src = \\\"./cat.jpeg\\\"; // 必须在同一域名下\\n\\nimage.onload = function () {\\n  main(image);\\n};\\n```\\n\"} />;\n  }\n  \n  export default Index;"],"names":["_jsx","MarkDown","srcDoc"],"sourceRoot":""}