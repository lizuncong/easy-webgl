{"version":3,"file":"static/js/A010.62cd6bd5.chunk.js","mappings":"sNAkCA,GA9BoBA,EAAAA,EAAAA,OAAKC,IAAuC,IAAtC,SAAEC,EAAQ,SAAEC,GAAoBF,EAAPG,GAAKC,EAAAA,EAAAA,GAAAJ,EAAAK,GACtD,MAAOC,EAAMC,IAAWC,EAAAA,EAAAA,WAAS,GAajC,OACEC,EAAAA,EAAAA,MAAA,OAAKC,UAAU,eAAcR,SAAA,EAC3BS,EAAAA,EAAAA,KAAA,QAAMD,UAAU,OAAOE,QAASA,IAdtBC,KACZ,MAAMC,EAAKC,SAASC,cAAc,YAClCF,EAAGG,MAAQJ,EACXE,SAASG,KAAKC,YAAYL,GAC1BA,EAAGM,SACHL,SAASM,YAAY,QACrBN,SAASG,KAAKI,YAAYR,GAC1BP,GAAQ,GACRgB,YAAW,KACThB,GAAQ,EAAM,GACb,IAAK,EAIgCiB,CAAKC,OAAOvB,IAAWA,SAC1DI,EAAO,iCAAU,kBAEpBK,EAAAA,EAAAA,KAACe,EAAAA,GAAiBC,EAAAA,EAAAA,GAAA,CAChBzB,SAAUuB,OAAOvB,GAAU0B,QAAQ,MAAO,IAC1C3B,SAAUA,EACVS,UAAU,UACVmB,OAAO,OACH1B,MAEF,I,uECsBV,QA1CA,SAAeH,GAAmB,IAAlB,IAAE8B,EAAG,OAAEC,GAAQ/B,EAC7B,MAAOgC,EAAQC,IAAazB,EAAAA,EAAAA,UAAS,IAYrC,OAXA0B,EAAAA,EAAAA,YAAU,KACJH,EACFE,EAAUF,GAGZI,MAAML,GACHM,MAAMC,GAAaA,EAASxB,SAC5BuB,MAAMvB,IACLoB,EAAUpB,EAAK,GACf,GACH,CAACiB,EAAKC,KAEPpB,EAAAA,EAAAA,KAAA,OAAKD,UAAU,gBAAeR,UAC5BS,EAAAA,EAAAA,KAAC2B,EAAAA,EAAa,CACZpC,SAAU8B,EACVO,cAAe,CAACC,EAAAA,GAChBC,cAAe,CAACC,EAAAA,GAChBC,WAAY,CACVC,IAAAA,CAAIC,GAAmD,IAAlD,KAAEC,EAAI,OAAEC,EAAM,UAAErC,EAAS,SAAER,GAAoB2C,EAAP1C,GAAKC,EAAAA,EAAAA,GAAAyC,EAAAxC,GAChD,MAAM2C,EAAQ,iBAAiBC,KAAKvC,GAAa,IACjD,OAAQqC,GAAUC,GAChBrC,EAAAA,EAAAA,KAACe,GAAiBC,EAAAA,EAAAA,GAAA,CAChBzB,SAAUuB,OAAOvB,GAAU0B,QAAQ,MAAO,IAC1C3B,SAAU+C,EAAM,GAChBtC,UAAU,UACVmB,OAAO,OACH1B,KAGNQ,EAAAA,EAAAA,KAAA,QAAAgB,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,CAAMjB,UAAWA,GAAeP,GAAK,IAAAD,SAClCA,IAGP,MAKV,C,8EC3CE,QAJA,WACE,OAAOS,EAAAA,EAAAA,KAACuC,EAAAA,EAAQ,CAACnB,OAAQ,kzIAC3B,C","sources":["components/markdown/highLighter.jsx","components/markdown/index.jsx","dynamic/pages/属性和缓冲/属性的两种赋值方式.jsx"],"sourcesContent":["import React, { memo, useState } from \"react\";\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport \"./index.less\";\n\nconst Highlighter = memo(({ language, children, ...props }) => {\n  const [show, setShow] = useState(false);\n  const copy = (text) => {\n    const el = document.createElement(\"textarea\");\n    el.value = text;\n    document.body.appendChild(el);\n    el.select();\n    document.execCommand(\"copy\");\n    document.body.removeChild(el);\n    setShow(true);\n    setTimeout(() => {\n      setShow(false);\n    }, 1000);\n  };\n  return (\n    <div className=\"high-lighter\">\n      <span className=\"copy\" onClick={() => copy(String(children))}>\n        {show ? \"复制成功！\" : \"复制\"}\n      </span>\n      <SyntaxHighlighter\n        children={String(children).replace(/\\n$/, \"\")}\n        language={language}\n        className=\"my-code\"\n        PreTag=\"div\"\n        {...props}\n      />\n    </div>\n  );\n});\n\nexport default Highlighter;\n","import React, { useState, useEffect } from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport remarkGfm from \"remark-gfm\";\nimport SyntaxHighlighter from \"./highLighter\";\nimport rehypeRaw from \"rehype-raw\";\n// import { tomorrow } from \"react-syntax-highlighter/dist/esm/styles/prism\";\nimport \"github-markdown-css\";\n\nimport \"./index.less\";\n\nfunction Shapes({ src, srcDoc }) {\n  const [mdText, setMdText] = useState(\"\");\n  useEffect(() => {\n    if (srcDoc) {\n      setMdText(srcDoc)\n      return;\n    }\n    fetch(src)\n      .then((response) => response.text())\n      .then((text) => {\n        setMdText(text);\n      });\n  }, [src, srcDoc]);\n  return (\n    <div className=\"markdown-body\">\n      <ReactMarkdown\n        children={mdText}\n        rehypePlugins={[rehypeRaw]}\n        remarkPlugins={[remarkGfm]}\n        components={{\n          code({ node, inline, className, children, ...props }) {\n            const match = /language-(\\w+)/.exec(className || \"\");\n            return !inline && match ? (\n              <SyntaxHighlighter\n                children={String(children).replace(/\\n$/, \"\")}\n                language={match[1]}\n                className=\"my-code\"\n                PreTag=\"div\"\n                {...props}\n              />\n            ) : (\n              <code className={className} {...props}>\n                {children}\n              </code>\n            );\n          },\n        }}\n      />\n    </div>\n  );\n}\n\nexport default Shapes;\n","import React from \"react\";\n  import MarkDown from \"@/components/markdown\";\n  \n  function Index() {\n    return <MarkDown srcDoc={\"## 前言\\n\\nWebGL代码由一对着色程序组成，即`顶点着色器`和`片段着色器`。着色器代码都是在GPU中运行，它们所需的任何数据都需要发送到GPU，在GPU中读取。着色器可以通过下面4种方法获取数据：\\n\\n- 属性(Attributes)和缓冲。属性仅适用于顶点着色器\\n- 全局变量（Uniforms）。在一次绘制中对所有顶点或者像素保持一致值。适用于顶点着色器和片段着色器\\n- 纹理（Textures）。从像素或纹理元素中获取的数据。适用于顶点着色器和片段着色器\\n- 可变量（Varyings）。顶点着色器给片段着色器传值的一种方式。给顶点着色器中可变量设置的值，会作为参考值进行内插，在绘制像素时传给片段着色器的可变量\\n\\n本篇文章主要讲的是`属性`和`缓冲`。`缓冲`是发送到GPU的一些二进制数据序列，是GPU中的一块内存区域，可以存储任何数据。`属性`用来指明怎么从缓冲中获取所需数据并将它提供给顶点着色器。\\n\\n本节使用到的html代码如下：\\n```html\\n<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n  <meta charset=\\\"utf-8\\\" />\\n  <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\" />\\n  <meta name=\\\"theme-color\\\" content=\\\"#000000\\\" />\\n  <meta name=\\\"description\\\" content=\\\"WebGL\\\" />\\n  <title>WebGL</title>\\n  <style>\\n    body {\\n      margin: 20px;\\n    }\\n    #webgl {\\n      width: 500px;\\n      height: 500px;\\n    }\\n    .container {\\n      font-size: 0;\\n      display: inline-block;\\n      border: 1px solid black;\\n      background: red;\\n    }\\n  </style>\\n</head>\\n<body>\\n  <div class=\\\"container\\\">\\n    <canvas width=\\\"500\\\" height=\\\"500\\\" id=\\\"webgl\\\">你的浏览器不支持canvas</canvas>\\n  </div>\\n  <script src=\\\"./initShaders.js\\\"></script>\\n  <script src=\\\"./index.js\\\"></script>\\n</body>\\n</html>\\n```\\n\\n## 属性\\n\\n在 WebGL 中，属性是顶点着色器的输入，可以直接给属性赋值，也可以从缓冲中获取数据。有两种方式可以给属性赋值：\\n\\n- `WebGLRenderingContext.vertexAttrib[1234]f[v]()`。这种方式不常用，了解一下即可\\n- 缓冲。常用的方式\\n\\n下面的代码通过gl.vertexAttrib2f给属性赋值绘制一个点：\\n\\n```js\\nconst canvas = document.getElementById('webgl')\\nconst gl = canvas.getContext('webgl')\\nconst vertexShaderSource = `\\n    attribute vec2 a_position1;\\n    void main() {\\n      gl_Position = vec4(a_position1, 0, 1);\\n      gl_PointSize = 10.0;\\n    }\\n`\\nconst fragmentShaderSource = `\\n    precision mediump float;\\n    void main() {\\n      gl_FragColor = vec4(1,0,0.5,1);\\n    }\\n`\\nconst program = initShaders(gl, vertexShaderSource, fragmentShaderSource)\\nconst positionLocation1 = gl.getAttribLocation(program, 'a_position1')\\n\\ngl.clearColor(0, 0, 0, 0)\\ngl.clear(gl.COLOR_BUFFER_BIT);\\n\\ngl.useProgram(program)\\ngl.vertexAttrib2f(positionLocation1, 0.5, 0.5)\\n\\ngl.drawArrays(gl.POINTS, 0, 1)\\n```\\n\\n结果如下，在(0.5,0.5)坐标上绘制了一个10 * 10大小的点\\n\"} />;\n  }\n  \n  export default Index;"],"names":["memo","_ref","language","children","props","_objectWithoutProperties","_excluded","show","setShow","useState","_jsxs","className","_jsx","onClick","text","el","document","createElement","value","body","appendChild","select","execCommand","removeChild","setTimeout","copy","String","SyntaxHighlighter","_objectSpread","replace","PreTag","src","srcDoc","mdText","setMdText","useEffect","fetch","then","response","ReactMarkdown","rehypePlugins","rehypeRaw","remarkPlugins","remarkGfm","components","code","_ref2","node","inline","match","exec","MarkDown"],"sourceRoot":""}