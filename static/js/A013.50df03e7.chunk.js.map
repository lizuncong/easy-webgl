{"version":3,"file":"static/js/A013.50df03e7.chunk.js","mappings":"yJAOE,QAJA,WACE,OAAOA,EAAAA,EAAAA,KAACC,EAAAA,EAAQ,CAACC,OAAQ,sshCAC3B,C","sources":["dynamic/pages/属性和缓冲/详解vertexAttribPointer.jsx"],"sourcesContent":["import React from \"react\";\n  import MarkDown from \"@/components/markdown\";\n  \n  function Index() {\n    return <MarkDown srcDoc={\"## 前言\\n\\n本篇文章对应的掘金地址：[https://juejin.cn/post/7443087089444536370](https://juejin.cn/post/7443087089444536370)\\n\\n在webgl中，我们调用`WebGLRenderingContext.vertexAttribPointer()`方法告诉显卡从当前绑定的缓冲区（bindBuffer() 指定的缓冲区）中读取顶点数据。本篇文章主要内容：\\n\\n- 详细解析vertexAttribPointer方法及各个参数的作用，看看属性如何从缓冲中读取数据。\\n- 如何使用同一个缓冲同时存储顶点的坐标和颜色等信息\\n- 如何使用同一个缓冲同时存储不同类型的数据\\n\\n语法：\\n\\n```js\\nvertexAttribPointer(index, size, type, normalized, stride, offset)\\n```\\n\\n可以用javascript伪代码表示如下：\\n\\n```js\\n// 伪代码\\ngl.vertexAttribPointer = function(location, size, type, normalize, stride, offset) {\\n  const attrib = gl.vertexArray.attributes[location];\\n  attrib.size = size;\\n  attrib.type = type;\\n  attrib.normalize = normalize;\\n  attrib.stride = stride ? stride : sizeof(type) * size;\\n  attrib.offset = offset;\\n  attrib.buffer = gl.arrayBuffer;  // !!!! <-----\\n};\\n```\\n\\n![image](../../easy-webgl/ver_01.webp)\\n\\n上图的顶点着色器中，position属性的type是vec4，但属性数组中，它的size设置成3，为什么？本节文章会解答这个问题。\\n\\n本篇文章会详细解读vertexAttribPointer方法的各个参数字段的作用。\\n\\n### 属性索引(Attribute index)\\n\\nvertexAttribPointer方法的第一个参数就是属性的索引，即属性在顶点数组(vertex array)中的索引。顶点数组能支持多少个顶点取决于显卡。可以调用`gl.getParameter(gl.MAX_VERTEX_ATTRIBS)`获取顶点数组支持的顶点数量。每个属性都必须指定索引，有两种方法可以指定索引：\\n\\n#### 1.手动绑定顶点索引。\\n\\n在调用`gl.linkProgram()`前，调用`bindAttribLocation`绑定顶点索引。比如：\\n\\n```js\\nconst positionLocation = 6; // 必须小于gl.getParameter(gl.MAX_VERTEX_ATTRIBS)\\ngl.bindAttribLocation(program, positionLocation, 'position');\\n```\\n\\n上面的代码将着色程序program中的position属性绑定在顶点数组中索引为6的位置上。后续可以直接将6传递给`gl.vertexAttribPointer()`。\\n\\n#### 2.显卡自动分配\\n\\n默认情况下，在编译顶点着色器时，显卡会自动为每个属性分配索引位置。每个属性的索引取决于显卡的分配，会有较大差异。这也就是为什么我们需要先调用`gl.getAttribLocation()`获取属性的索引，然后再赋值给`gl.vertexAttribPointer()`\\n\\n### SIZE\\n\\nvertexAttribPointer方法的第二个参数就是size。size用来指定每个顶点属性的组成数量，必须是 1，2，3或4。实际上这就是我们在顶点着色器中声明属性时的`vec[1234]`的大小。所以`size`最大为4。\\n\\n在继续之前，我们先回顾一下上一篇文章中[【WebGL】深入理解属性和缓冲](https://juejin.cn/post/7440065311319326747#heading-3)讲的属性默认值对象。每个属性都有默认值，存在`gl.attributeValues`数组中。属性的默认值为`vec4(0.0, 0.0, 0.0, 1.0)`。我们可以通过`gl.vertexAttrib[1234]f[v]()`修改默认值。或者通过gl.enableVertexAttribArray()告诉webgl从缓冲中读取数据。\\n\\n以下面的代码为例，我们在顶点着色器中使用`vec4`告诉webgl，`a_position`期望的是4个数字。\\n\\n```js\\nconst vertexShaderSource1 = `\\n    attribute vec4 a_position;\\n    void main(){\\n        gl_PointSize = 10.0;\\n        gl_Position = vec4(a_position);\\n    }\\n`\\n```\\n\\n当我们调用gl.vertexAttribPointer并将size设为2时，**webgl会先从缓冲中读取两个数字，然后第三和第四个数字会从默认值vec4(0.0, 0.0, 0.0, 1.0)中读取**。\\n比如下面的代码，顶点着色器运行三次，属性a\\\\_position最终的值为：\\n\\n*   vec(-0.5, 0.0, 0.0, 1.0)\\n*   vec(0.5, 0.0, 0.0, 1.0)\\n*   vec(0.0, 0.0, 0.0, 1.0)\\n\\n```js\\n let positions = [\\n    -0.5, 0.0,\\n    0.5, 0.0,\\n    0.0, 0.0\\n  ]\\n gl.vertexAttribPointer(\\n    positionLocation1,\\n    2, // size\\n    gl.FLOAT, // type, buffer的数据类型\\n    false,\\n    0, // 每个点的信息所占的bytes\\n    0\\n  )\\n```\\n\\n需要特别注意的是，即使调用`gl.vertexAttrib3f(positionLocation1, 0.0, 0.5, 0.6);`修改了属性的默认值，webgl在读取缓冲时，默认值还是按照vec4(0.0, 0.0, 0.0, 1.0)读取。比如下面的代码：\\n\\n```js\\nconst main = () => {\\n  const canvas = document.getElementById('webgl')\\n  const gl = canvas.getContext('webgl2')\\n  const vertexShaderSource1 = `\\n    attribute vec4 a_position;\\n    void main(){\\n        gl_PointSize = 10.0;\\n        gl_Position = vec4(a_position);\\n    }\\n  `\\n  const fragmentShaderSource1 = `\\n    precision mediump float;\\n    void main(){\\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n    }\\n  `\\n  const program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1)\\n\\n  const positionLocation1 = gl.getAttribLocation(program1, 'a_position')\\n  gl.vertexAttrib3f(positionLocation1, 0.0, 0.5, 0.6);\\n\\n  let positions = [\\n    -0.5,\\n    0.5,\\n    0.0, \\n  ]\\n  positions = new Float32Array(positions)\\n\\n\\n\\n  const positionBuffer = gl.createBuffer();\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\\n  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW)\\n\\n  // 设置属性positionLocation1的一系列状态，告诉它应该怎么从缓冲中读取数据\\n  // 定义点的信息\\n  gl.vertexAttribPointer(\\n    positionLocation1,\\n    1, \\n    gl.FLOAT, // type, buffer的数据类型\\n    false,\\n    0, // 每个点的信息所占的bytes\\n    0\\n  );\\n \\n\\n  gl.enableVertexAttribArray(positionLocation1);\\n\\n  gl.clearColor(0, 0, 0, 0)\\n  gl.clear(gl.COLOR_BUFFER_BIT);\\n\\n  gl.useProgram(program1)\\n  // 告诉webgl绘制3个点\\n  gl.drawArrays(gl.POINTS, 0, 3)\\n\\n}\\n\\nmain();\\n```\\n\\n上面的代码，我们先调用`gl.vertexAttrib3f(positionLocation1, 0.0, 0.5, 0.6);`修改了属性a\\\\_position的默认值。a\\\\_position的默认值变成vec4(0.0, 0.5, 0.6,1.0)。\\n\\n然后我们通过缓冲传递了3个数字，并调用`gl.vertexAttribPointer`告诉webgl怎么从缓冲中读取数据，这里我们将size设为1，因此顶点着色器运行三次，a\\\\_position的最终取值：\\n\\n*   vec(-0.5, 0.0, 0.0, 1.0)\\n*   vec(0.5, 0.0, 0.0, 1.0)\\n*   vec(0.0, 0.0, 0.0, 1.0)\\n\\n而不是\\n\\n*   vec(-0.5, 0.5, 0.6, 1.0)\\n*   vec(0.5, 0.5, 0.6, 1.0)\\n*   vec(0.0, 0.5, 0.6, 1.0)\\n\\n效果如下，从图中可以看出三个点的y轴方向均为0.0，而不是0.5\\n\\n![image](../../easy-webgl/ver_02.webp)\\n\\n> MDN关于size从[缓冲和默认值取值](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/vertexAttribPointer#default_attribute_values)的描述应该是个陷阱，上面的实践结果表明即使改变了默认值，webgl读取默认值时还是会按照vec4(0.0, 0.0, 0.0, 1.0)读取\\n\\n### TYPE\\n\\nvertexAttribPointer方法的第三个参数就是type。type用来指定数组中每个元素的数据类型，可以是下面的类型：\\n\\n*   gl.BYTE：有符号的8位整数，范围\\\\[-128, 127]。一个数字占1个字节。可以使用new Int8Array创建\\n*   gl.SHORT：有符号的16位整数，范围\\\\[-32768, 32767]。一个数字占2个字节。可以使用new Int16Array创建\\n*   gl.UNSIGNED\\\\_BYTE：无符号的8位整数，范围 \\\\[0, 255]。一个数字占1个字节。可以使用new Uint8Array创建\\n*   gl.UNSIGNED\\\\_SHORT：无符号的16位整数，范围\\\\[0, 65535]。一个数字占2个字节。可以使用new Uint16Array创建\\n*   gl.FLOAT：32位IEEE标准的浮点。一个数字占4个字节。可以使用new Float32Array创建\\n*   使用 WebGL2 版本的还可以使用以下值：gl.HALF\\\\_FLOAT\\n\\n### NORMALIZED(归一化)\\n\\nvertexAttribPointer方法的第四个参数就是normalized。在WebGL中，归一化是指将数据按比例缩放到一个特定范围的过程，通常是 \\\\[0, 1] 或 \\\\[-1, 1]。这个过程在图形编程中非常重要，因为它可以帮助我们更好地控制颜色、纹理坐标和法向量等数据，从而实现更加精确和高效的渲染。`归一化`适用于所有非浮点型数据。\\n\\n如果传递`false`就**解读原数据类型**。 BYTE类型的范围是从-128到127，UNSIGNED\\\\_BYTE类型的范围是从0到255，SHORT类型的范围是从-32768到32767，等等...\\n\\n如果设为`true`，BYTE数据的值(-128 to 127)将会转换到-1.0到+1.0之间，UNSIGNED\\\\_BYTE (0 to 255) 变为 0.0 到 +1.0 之间，SHORT 也是转换到 -1.0 到 +1.0 之间，但比BYTE精确度高。\\n\\n*   对于类型gl.BYTE和gl.SHORT，如果是 true 则将值归一化为 \\\\[-1, 1]\\n*   对于类型gl.UNSIGNED\\\\_BYTE和gl.UNSIGNED\\\\_SHORT，如果是 true 则将值归一化为 \\\\[0, 1]\\n*   对于类型gl.FLOAT和gl.HALF\\\\_FLOAT，此参数无效\\n\\n最常用的是标准化颜色数据，将颜色值从\\\\[0, 255]范围缩放到\\\\[0, 1]范围，这样可以简化计算并提高渲染性能。用javascript实现就是：\\n\\n```js\\nfunction normalizeColor(color) {\\n  return color.map(c => c / 255);\\n}\\n```\\n\\n在webgl中，颜色值范围为0.0到+1.0。使用4个浮点型数据存储红，绿，蓝和阿尔法通道数据时，每个顶点的颜色将会占用16字节空间（一个gl.FLOAT类型数据占用4个字节），如果你有复杂的几何体将会占用很多内存。代替的做法是将颜色数据转换为四个UNSIGNED\\\\_BYTE，其中0表示0.0，255表示 1.0。现在每个顶点只需要四个字节存储颜色值，省了75% 空间。\\n\\n比如下面使用UNSIGNED\\\\_BYTE传送颜色数据：\\n\\n```js\\nimport initShaders from \\\"./initShaders.js\\\";\\n\\n\\nconst main = () => {\\n  const canvas = document.getElementById('webgl')\\n  const gl = canvas.getContext('webgl')\\n  const vertexShaderSource1 = `\\n    attribute vec3 a_position;\\n    attribute vec3 a_color;\\n    varying vec3 v_color;\\n    void main(){\\n        v_color = a_color;\\n        gl_PointSize = 10.0;\\n        gl_Position = vec4(a_position, 1.0);\\n    }\\n  `\\n  const fragmentShaderSource1 = `\\n    precision mediump float;\\n    varying vec3 v_color;\\n    void main(){\\n        gl_FragColor = vec4(v_color, 1.0);\\n    }\\n  `\\n  const program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1)\\n\\n  const positionLocation1 = gl.getAttribLocation(program1, 'a_position')\\n  const colorPosition = gl.getAttribLocation(program1, 'a_color')\\n\\n  let positions = [\\n    -0.5, 0.0,\\n    0.5, 0.0, \\n    0.0, 0.5,\\n  ]\\n  let colors = [ // 这些数据在存入缓冲时将被截取成Uint8Array类型\\n    255, 0.1, 0.1111,// 会被截取成255,0,0\\n    0.222, 255, 0,// 会被截取成0,255,0\\n    0, 0, 255.888, // 会被截取成0, 0, 255\\n  ]\\n  colors = new Uint8Array(colors)\\n  positions = new Float32Array(positions)\\n\\n\\n\\n  const FSIZE = positions.BYTES_PER_ELEMENT // 4\\n  const ISIZE = colors.BYTES_PER_ELEMENT // 1\\n\\n  console.log('positions...',FSIZE, positions)\\n\\n  const positionBuffer = gl.createBuffer();\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\\n  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW)\\n\\n  const colorBuffer = gl.createBuffer();\\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer)\\n  gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW)\\n\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\\n  gl.vertexAttribPointer(\\n    positionLocation1,\\n    2, // size，\\n    gl.FLOAT, // type, buffer的数据类型\\n    false,\\n    2 * FSIZE, // 每个点的信息所占的bytes\\n    0\\n  );\\n\\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer)\\n  gl.vertexAttribPointer(\\n    colorPosition,\\n    3, // size，\\n    gl.UNSIGNED_BYTE,\\n    true,// 需要归一化\\n    3 * ISIZE,\\n    0\\n  );\\n\\n  // 告诉webgl，属性positionLocation1应该从缓冲中读取数据，而不是从attributeValues中读取数据\\n  gl.enableVertexAttribArray(positionLocation1);\\n  gl.enableVertexAttribArray(colorPosition);\\n\\n  gl.clearColor(0, 0, 0, 0)\\n  gl.clear(gl.COLOR_BUFFER_BIT);\\n\\n  gl.useProgram(program1)\\n  // 告诉webgl绘制3个点\\n  gl.drawArrays(gl.POINTS, 0, 3)\\n\\n}\\n\\nmain();\\n\\n```\\n\\n效果如下：\\n\\n![image](../../easy-webgl/ver_03.webp)\\n\\n### STRIDE 和 OFFSET\\n\\n`stride`：以字节为单位指定连续顶点属性开始之间的偏移(即数组中一行长度)。不能大于255。如果 stride为0，则假定该属性是紧密打包的，即不`交错属性`，每个属性在一个单独的块中，下一个顶点的属性紧跟当前顶点之后。具体可看[这里](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/vertexAttribPointer#stride)\\n\\n`offset`：指定顶点属性数组中第一部分的字节偏移量。必须是类型的字节长度的倍数。\\n\\n在[webglfundamentals](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-how-it-works.html)中提到，如果stride和offset使用 0 以外的值时会复杂得多，虽然这样会取得一些性能能上的优势， 但是一般情况下并不值得，除非你想充分压榨WebGL的性能。\\n\\n具体点，stride表示顶点着色器每执行一次，从缓冲中读取的一个片段，或者说顶点着色器每次执行，都需要前进的字节数。\\n\\n> 交错属性：即使用同一个缓冲存储两个或多个属性需要的数据\\n\\n假设我们有下面的顶点着色器：\\n\\n```js\\nconst vertexShaderSource1 = `\\n    attribute vec3 a_position;\\n    attribute vec3 a_color;\\n    varying vec3 v_color;\\n    void main(){\\n        v_color = a_color;\\n        gl_PointSize = 10.0;\\n        gl_Position = vec4(a_position, 1.0);\\n    }\\n`\\n```\\n\\n我们使用同一个`positions`缓冲存储每个顶点的坐标和颜色数据，下面数组中，每一行前两个表示顶点的坐标，后面三个表示顶点的颜色值。\\n\\n```js\\n  let positions = [\\n    // x y  r g b 前面两个代表坐标，后面三个代表颜色rgb的值\\n    -0.5, 0.0, 1.0, 0.0, 0.0,\\n    0.5, 0.0, 0.0, 1.0, 0.0,\\n    0.0, 0.8, 0.0, 0.0, 1.0\\n  ]\\n  positions = new Float32Array(positions)\\n```\\n\\n然后调用gl.vertexAttribPointer告诉webgl怎么从缓冲中读取数据：\\n\\n```js\\n  gl.vertexAttribPointer(\\n    positionLocation1,\\n    2, // size，\\n    gl.FLOAT, // type, buffer的数据类型\\n    false,\\n    5 * FSIZE, // 每个点的信息所占的bytes\\n    0\\n  );\\n  gl.vertexAttribPointer(\\n    colorPosition,\\n    3, // size，attribute变量的长度(vec3)\\n    gl.FLOAT,\\n    false,\\n    5 * FSIZE,\\n    2 * FSIZE\\n  );\\n```\\n\\n`positions`缓冲中，每个数字占用4个字节，我们用每5个数字存储一个顶点的坐标和颜色数据，因此一个顶点需要的坐标和颜色数据占用5 \\\\* 4 = 20个字节。比如下图所示，每一行(4个字节)表示一个数字，比如`00 00 00 BF`表示0.5。`00 00 00 00`表示0.0。\\n\\n顶点着色器每次运行读取`stride`（即传给gl.vertexAttribPointer方法的stride参数的值）个字节。然后这stride个字节中，又有坐标数据，又有颜色数据，那怎么读取每个属性的数据？这就是offet的作用\\n\\n![image](../../easy-webgl/ver_04.webp)\\n\\n![image](../../easy-webgl/ver_05.webp)\\n\\n\\n### 不同数据类型的交错属性\\n\\n到目前为止，我们基本都是用buffer传递类型固定的数据给GPU，那能不能用同一个buffer传递包含不同数据类型的数据到GPU？本节我们就来实践一下。\\n\\n我们使用下面的数据结构表示一个顶点的数据，数组中每一项代表一个顶点，每个顶点包含坐标(position)和颜色(color)数据。坐标使用gl.FLOAT存储，需要8个字节。颜色使用gl.UNSIGNED\\\\_BYTE存储，需要4个字节，所以一个顶点需要12个字节\\n\\n```js\\n  // position需要8个字节，color需要4个字节，所以一个顶点需要12个字节\\n  const verticesInfo = [\\n    {\\n      position: [-0.5, 0.0], // 需要8个字节\\n      color: [255, 0, 0, 255], // 需要4个字节\\n    },\\n    {\\n      position: [0.5, 0.0],\\n      color: [0, 255, 0, 255],\\n    },\\n    {\\n      position: [0.0, 0.8],\\n      color: [0, 0, 255, 255]\\n    }\\n  ]\\n```\\n\\n根据以上数据创建缓冲：\\n\\n```js\\n\\n  // position需要8个字节，color需要4个字节，所以一个顶点需要12个字节\\n  const totalSizePerVertex = 12;\\n  const buffer = new ArrayBuffer(totalSizePerVertex * verticesInfo.length)\\n  const dv = new DataView(buffer);\\n  for (let i = 0; i < verticesInfo.length; i++) {\\n    const vertex = verticesInfo[i]\\n    dv.setFloat32(totalSizePerVertex * i, vertex.position[0], true)\\n    dv.setFloat32(totalSizePerVertex * i + 4, vertex.position[1], true)\\n    dv.setUint8(totalSizePerVertex * i + 8, vertex.color[0], true)\\n    dv.setUint8(totalSizePerVertex * i + 9, vertex.color[1], true)\\n    dv.setUint8(totalSizePerVertex * i + 10, vertex.color[2], true)\\n    dv.setUint8(totalSizePerVertex * i + 11, vertex.color[3], true)\\n\\n  }\\n  console.log('buffer...', buffer)\\n```\\n\\n然后告诉WebGL怎么读取缓冲：\\n\\n```js\\n  const vertexBuffer = gl.createBuffer();\\n  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\\n  gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW)\\n\\n  // 设置属性positionLocation1的一系列状态，告诉它应该怎么从缓冲中读取数据\\n  // 定义点的信息\\n  gl.vertexAttribPointer(\\n    positionLocation1,\\n    2, \\n    gl.FLOAT, \\n    false,\\n    totalSizePerVertex, \\n    0\\n  );\\n  gl.vertexAttribPointer(\\n    colorPosition,\\n    4, \\n    gl.UNSIGNED_BYTE,\\n    true,\\n    totalSizePerVertex,\\n    2 * Float32Array.BYTES_PER_ELEMENT\\n  );\\n```\\n\\n绘制结果如下：\\n\\n![image](../../easy-webgl/ver_06.webp)\\n\\n完整代码如下：\\n\\n```js\\nimport initShaders from \\\"./initShaders.js\\\";\\n\\n\\nconst main = () => {\\n  const canvas = document.getElementById('webgl')\\n  const gl = canvas.getContext('webgl')\\n  const vertexShaderSource1 = `\\n    attribute vec3 a_position;\\n    attribute vec4 a_color;\\n    varying vec4 v_color;\\n    void main(){\\n        v_color = a_color;\\n        gl_PointSize = 10.0;\\n        gl_Position = vec4(a_position, 1.0);\\n    }\\n  `\\n  const fragmentShaderSource1 = `\\n    precision mediump float;\\n    varying vec4 v_color;\\n    void main(){\\n        gl_FragColor = vec4(v_color);\\n    }\\n  `\\n  const program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1)\\n\\n  const positionLocation1 = gl.getAttribLocation(program1, 'a_position')\\n  const colorPosition = gl.getAttribLocation(program1, 'a_color')\\n\\n  // position需要8个字节，color需要4个字节，所以一个顶点需要12个字节\\n  const verticesInfo = [\\n    {\\n      position: [-0.5, 0.0], // 需要8个字节\\n      color: [255, 0, 0, 255], // 需要4个字节\\n    },\\n    {\\n      position: [0.5, 0.0],\\n      color: [0, 255, 0, 255],\\n    },\\n    {\\n      position: [0.0, 0.8],\\n      color: [0, 0, 255, 255]\\n    }\\n  ]\\n\\n  // position需要8个字节，color需要4个字节，所以一个顶点需要12个字节\\n  const totalSizePerVertex = 12;\\n  const buffer = new ArrayBuffer(totalSizePerVertex * verticesInfo.length)\\n  const dv = new DataView(buffer);\\n  for (let i = 0; i < verticesInfo.length; i++) {\\n    const vertex = verticesInfo[i]\\n    dv.setFloat32(totalSizePerVertex * i, vertex.position[0], true)\\n    dv.setFloat32(totalSizePerVertex * i + 4, vertex.position[1], true)\\n    dv.setUint8(totalSizePerVertex * i + 8, vertex.color[0], true)\\n    dv.setUint8(totalSizePerVertex * i + 9, vertex.color[1], true)\\n    dv.setUint8(totalSizePerVertex * i + 10, vertex.color[2], true)\\n    dv.setUint8(totalSizePerVertex * i + 11, vertex.color[3], true)\\n\\n  }\\n  console.log('buffer...', buffer)\\n  const vertexBuffer = gl.createBuffer();\\n  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\\n  gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW)\\n\\n  // 设置属性positionLocation1的一系列状态，告诉它应该怎么从缓冲中读取数据\\n  // 定义点的信息\\n  gl.vertexAttribPointer(\\n    positionLocation1,\\n    2, \\n    gl.FLOAT, \\n    false,\\n    totalSizePerVertex, \\n    0\\n  );\\n  gl.vertexAttribPointer(\\n    colorPosition,\\n    4, \\n    gl.UNSIGNED_BYTE,\\n    true,\\n    totalSizePerVertex,\\n    2 * Float32Array.BYTES_PER_ELEMENT\\n  );\\n\\n\\n  gl.enableVertexAttribArray(positionLocation1);\\n  gl.enableVertexAttribArray(colorPosition);\\n\\n  gl.clearColor(0, 0, 0, 0)\\n  gl.clear(gl.COLOR_BUFFER_BIT);\\n\\n  gl.useProgram(program1)\\n  // 告诉webgl绘制3个点\\n  gl.drawArrays(gl.POINTS, 0, 3)\\n\\n}\\n\\nmain();\\n```\\n\\n#### 交错属性需要特别注意的点\\n\\n回顾一下，传递给vertexAttribPointer的stride参数的值必须是传递的数据类型的大小的整数倍。\\n比如传递给vertexAttribPointer的type是gl.FLOAT，那么stride必须是4的整数倍\\n\\n```js\\nvertexAttribPointer(index, size, type, normalized, stride, offset)\\n```\\n\\n这在使用缓冲存储不同数据类型的交错属性时尤其需要注意，比如下面的数据：\\n\\n```js\\n  // position需要8个字节，color需要3个字节，所以一个顶点需要11个字节\\n  const verticesInfo = [\\n    {\\n      position: [-0.5, 0.0], // 需要8个字节\\n      color: [255, 0, 0], // 需要3个字节\\n    },\\n    {\\n      position: [0.5, 0.0],\\n      color: [0, 255, 0],\\n    },\\n    {\\n      position: [0.0, 0.8],\\n      color: [0, 0, 255]\\n    }\\n  ]\\n```\\n\\n这里一个顶点需要11个字节，当我们调用vertexAttribPointer给position属性指定如何读取缓冲时：\\n\\n```js\\n  gl.vertexAttribPointer(\\n    positionLocation1,\\n    2, \\n    gl.FLOAT, \\n    false,\\n    totalSizePerVertex, \\n    0\\n  );\\n```\\n\\n由于type是gl.FLOAT，即4个字节，但是stride并不是4的倍数，此时是会报错的，如下面所示：\\n\\n![image](../../easy-webgl/ver_07.webp)\\n\\n可以通过下面的代码验证：\\n\\n```js\\nimport initShaders from \\\"./initShaders.js\\\";\\n\\n\\nconst main = () => {\\n  const canvas = document.getElementById('webgl')\\n  const gl = canvas.getContext('webgl')\\n  const vertexShaderSource1 = `\\n    attribute vec3 a_position;\\n    attribute vec3 a_color;\\n    varying vec3 v_color;\\n    void main(){\\n        v_color = a_color;\\n        gl_PointSize = 10.0;\\n        gl_Position = vec4(a_position, 1.0);\\n    }\\n  `\\n  const fragmentShaderSource1 = `\\n    precision mediump float;\\n    varying vec3 v_color;\\n    void main(){\\n        gl_FragColor = vec4(v_color, 1.0);\\n    }\\n  `\\n  const program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1)\\n\\n  const positionLocation1 = gl.getAttribLocation(program1, 'a_position')\\n  const colorPosition = gl.getAttribLocation(program1, 'a_color')\\n\\n  // position需要8个字节，color需要3个字节，所以一个顶点需要11个字节\\n  const verticesInfo = [\\n    {\\n      position: [-0.5, 0.0], // 需要8个字节\\n      color: [255, 0, 0], // 需要3个字节\\n    },\\n    {\\n      position: [0.5, 0.0],\\n      color: [0, 255, 0],\\n    },\\n    {\\n      position: [0.0, 0.8],\\n      color: [0, 0, 255]\\n    }\\n  ]\\n\\n  // position需要8个字节，color需要3个字节，所以一个顶点需要11个字节\\n  const totalSizePerVertex = 11;\\n  const buffer = new ArrayBuffer(totalSizePerVertex * verticesInfo.length)\\n  const dv = new DataView(buffer);\\n  for (let i = 0; i < verticesInfo.length; i++) {\\n    const vertex = verticesInfo[i]\\n    dv.setFloat32(totalSizePerVertex * i, vertex.position[0], true)\\n    dv.setFloat32(totalSizePerVertex * i + 4, vertex.position[1], true)\\n    dv.setUint8(totalSizePerVertex * i + 8, vertex.color[0], true)\\n    dv.setUint8(totalSizePerVertex * i + 9, vertex.color[1], true)\\n    dv.setUint8(totalSizePerVertex * i + 10, vertex.color[2], true)\\n\\n  }\\n  console.log('buffer...', buffer)\\n  const vertexBuffer = gl.createBuffer();\\n  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\\n  gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW)\\n\\n\\n  gl.vertexAttribPointer(\\n    positionLocation1,\\n    2, \\n    gl.FLOAT, \\n    false,\\n    totalSizePerVertex, \\n    0\\n  );\\n  gl.vertexAttribPointer(\\n    colorPosition,\\n    3, \\n    gl.UNSIGNED_BYTE,\\n    true,\\n    totalSizePerVertex,\\n    2 * Float32Array.BYTES_PER_ELEMENT\\n  );\\n\\n\\n  gl.enableVertexAttribArray(positionLocation1);\\n  gl.enableVertexAttribArray(colorPosition);\\n\\n  gl.clearColor(0, 0, 0, 0)\\n  gl.clear(gl.COLOR_BUFFER_BIT);\\n\\n  gl.useProgram(program1)\\n  // 告诉webgl绘制3个点\\n  gl.drawArrays(gl.POINTS, 0, 3)\\n\\n}\\n\\nmain();\\n```\\n\\n## 参考\\n\\n*   [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/vertexAttribPointer#stride)\\n*   [webglfundamentals](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-how-it-works.html)\\n\"} />;\n  }\n  \n  export default Index;"],"names":["_jsx","MarkDown","srcDoc"],"sourceRoot":""}