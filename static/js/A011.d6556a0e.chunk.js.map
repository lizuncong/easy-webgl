{"version":3,"file":"static/js/A011.d6556a0e.chunk.js","mappings":"0JAOE,QAJA,WACE,OAAOA,EAAAA,EAAAA,KAACC,EAAAA,EAAQ,CAACC,OAAQ,ksRAC3B,C","sources":["dynamic/pages/坐标系统/纹理坐标.jsx"],"sourcesContent":["import React from \"react\";\n  import MarkDown from \"@/components/markdown\";\n  \n  function Index() {\n    return <MarkDown srcDoc={\"## 纹理坐标\\n\\n纹理是通过“纹理坐标”来引用的， 纹理坐标 0.0 到 1.0 对应纹理从左到右，0.0 到 1.0 对应第一个像素所在行到最后一行。纹理坐标是没有上下的概念的，主要是依据传递给WebGL的纹理数据，纹理数据的开头对应纹理坐标(0, 0)， 结尾对应纹理坐标(1, 1)。\\n\\n## 纹理坐标原点\\n在社区大部分文章中，都普遍认为WebGL纹理坐标的原点在左下角。比如在[webglfundamentals](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-3d-textures.html)一文中，也认为WebGL纹理坐标在左下角：\\n\\n![image](../../easy-webgl/texture_01.jpg)\\n\\n实际上，在OpenGL中，纹理坐标的原点确实在左下角。而在WebGL中，纹理坐标的原点在左上角！！下面我们将通过例子验证\\n\\n\\n下图中，灰色背景区域是Canvas画布，我们在(0,0)，(0, 0.5), (0.5,0.5), (0.5, 0)处画一个矩形。\\n\\n![image](../../easy-webgl/texture_02.png)\\n\\n对应的矩形坐标为：\\n\\n```js\\nconst rectX = 0.5, rectY =  0.5;\\nlet verticesInfo = [\\n    0.0, rectY,\\n    rectX, rectY,\\n    0, 0,\\n    rectX, rectY,\\n    0, 0,\\n    rectX, 0,\\n]\\nverticesInfo = new Float32Array(verticesInfo)\\n```\\n\\n矩形的坐标顺序需要和纹理贴图的坐标顺序一一对应。上图中，绿色字体的1，2，3，4，5，6就是矩形的坐标顺序。\\n\\n假设WebGL中纹理贴图的原点在左下角，我们使用下面的图片贴到上面的矩形中\\n\\n![image](../../easy-webgl/f.png)\\n\\n那么纹理坐标和矩形的坐标对应关系就如下图所示，图中绿色字体就是表示坐标在缓冲中的顺序。\\n\\n![image](../../easy-webgl/texture_03.png)\\n\\n因此，对应的纹理坐标应该如下：\\n\\n```js\\nconst x = 1.0, y = 1.0;\\n// 假设WebGL纹理坐标的原点在左下角，那么纹理坐标应该如下：\\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\\n    0.0, y,\\n    x, y,\\n    0.0, 0.0,\\n    x, y,\\n    0.0,0.0,\\n    x, 0\\n]), gl.STATIC_DRAW);\\n```\\n\\n实际绘制的结果如下图所示，可以看到，贴图是颠倒的！！\\n\\n![image](../../easy-webgl/texture_04.jpg)\\n\\n完整demo如下：\\n```js\\nconst main = (image) => {\\n    const canvas = document.getElementById('webgl')\\n    const gl = canvas.getContext('webgl')\\n    const vertexShaderSource1 = `\\n      attribute vec2 a_texCoord;\\n      attribute vec2 a_position;\\n      varying vec2 v_texCoord;\\n      void main(){\\n          gl_PointSize = 10.0;\\n          gl_Position = vec4(a_position, 0.0, 1.0);\\n          // 将纹理坐标传给片段着色器\\n          // GPU会在点之间进行插值\\n          v_texCoord = a_texCoord;\\n      }\\n    `\\n    const fragmentShaderSource1 = `\\n      precision mediump float;\\n      uniform sampler2D u_image;\\n      // 从顶点着色器传入的纹理坐标\\n      varying vec2 v_texCoord;\\n      void main(){\\n        // 在纹理上寻找对应颜色值\\n        gl_FragColor = texture2D(u_image, v_texCoord);\\n      }\\n    `\\n    const program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1)\\n    const positionLocation1 = gl.getAttribLocation(program1, 'a_position')\\n    const texCoordLocation = gl.getAttribLocation(program1, \\\"a_texCoord\\\");\\n  \\n    // 给矩形提供纹理坐标\\n    const texCoordBuffer = gl.createBuffer();\\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\\n    const x = 1.0, y = 1.0;\\n    // 假设WebGL纹理坐标的原点在左下角，那么纹理坐标应该如下：\\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\\n     0.0, y,\\n     x, y,\\n     0.0, 0.0,\\n     x, y,\\n     0.0,0.0,\\n     x, 0\\n    ]), gl.STATIC_DRAW);\\n\\n    // WebGL纹理坐标的原点在左上角，因此我们应该按下面的顺序提供纹理坐标：\\n    // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\\n    //   0.0, 0.0,\\n    //   x, 0.0,\\n    //   0.0, y,\\n    //   x, 0.0,\\n    //   0.0, y,\\n    //   x, y\\n    // ]), gl.STATIC_DRAW);\\n    gl.enableVertexAttribArray(texCoordLocation);\\n    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\\n  \\n    // 创建纹理\\n    var texture = gl.createTexture();\\n    gl.bindTexture(gl.TEXTURE_2D, texture);\\n  \\n    // 设置参数，让我们可以绘制任何尺寸的图像\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\\n  \\n    // 将图像上传到纹理\\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\n  \\n    const rectX = 0.5, rectY =  0.5;\\n    let verticesInfo = [\\n      0.0, rectY,\\n      rectX, rectY,\\n      0, 0,\\n      rectX, rectY,\\n      0, 0,\\n      rectX, 0,\\n    ]\\n    verticesInfo = new Float32Array(verticesInfo)\\n  \\n    const vertexBuffer = gl.createBuffer();\\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\\n    gl.bufferData(gl.ARRAY_BUFFER, verticesInfo, gl.STATIC_DRAW)\\n  \\n  \\n    gl.vertexAttribPointer(\\n      positionLocation1,\\n      2,\\n      gl.FLOAT,\\n      false,\\n      8,\\n      0\\n    );\\n  \\n  \\n  \\n    gl.clearColor(0, 0, 0, 0.1)\\n  \\n    gl.clear(gl.COLOR_BUFFER_BIT);\\n  \\n    gl.useProgram(program1)\\n  \\n    gl.enableVertexAttribArray(positionLocation1);\\n  \\n    gl.drawArrays(gl.TRIANGLES, 0,6)\\n  \\n  }\\n  \\n  \\n  const image = new Image();\\n  image.src = \\\"./f.png\\\";  // 必须在同一域名下\\n  image.onload = function () {\\n    main(image);\\n  }\\n```\\n\\n实际上，WebGL纹理的原点在左上角。如下图所示：\\n\\n![image](../../easy-webgl/texture_05.png)\\n\\n因此我们应该这样提供纹理坐标：\\n\\n```js\\nconst x = 1.0, y = 1.0;\\n// WebGL纹理坐标的原点在左上角，因此我们应该按下面的顺序提供纹理坐标：\\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\\n    0.0, 0.0,\\n    x, 0.0,\\n    0.0, y,\\n    x, 0.0,\\n    0.0, y,\\n    x, y\\n]), gl.STATIC_DRAW);\\n```\\n\\n实际的绘制结果如下图，可以看到结果是正确的\\n\\n![image](../../easy-webgl/texture_06.jpg)\\n\\n## 结论\\n在OpenGL中，纹理贴图的原点在左下角。而在WebGL中，纹理贴图的原点实际上在左上角。如果在WebGL中将左下角当作纹理贴图的原点并提供纹理坐标，需要设置gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\\n\\n## 参考\\n- [三维纹理](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-3d-textures.html)\\n- [为什么WebGL纹理是颠倒的](https://jameshfisher.com/2020/10/22/why-is-my-webgl-texture-upside-down/)\\n\\n\"} />;\n  }\n  \n  export default Index;"],"names":["_jsx","MarkDown","srcDoc"],"sourceRoot":""}