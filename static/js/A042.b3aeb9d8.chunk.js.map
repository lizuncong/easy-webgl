{"version":3,"file":"static/js/A042.b3aeb9d8.chunk.js","mappings":"0JAOE,QAJA,WACE,OAAOA,EAAAA,EAAAA,KAACC,EAAAA,EAAQ,CAACC,OAAQ,mxrBAC3B,C","sources":["dynamic/pages/纹理/纹理尺寸.jsx"],"sourcesContent":["import React from \"react\";\n  import MarkDown from \"@/components/markdown\";\n  \n  function Index() {\n    return <MarkDown srcDoc={\"## 一、 纹理尺寸\\n\\nWebGL 对纹理维度的限制主要源于其基于 OpenGL ES 2.0 规范，该规范要求纹理的宽度和高度必须是 2 的整数次幂（如 1x1, 2x2, 4x4, 8x8 等）。这一限制影响了纹理的渲染和性能。\\n\\n### 1.1 限制的原因\\n\\n- **性能优化**：2 的幂次方纹理可以更高效地使用硬件加速，提高渲染性能。\\n- **纹理过滤和 mipmap 生成**：2 的幂次方纹理支持更高质量的纹理过滤和 mipmap 生成，提升图像质量。\\n\\n### 1.2 如何处理非 2 的幂次方纹理\\n\\n- **调整纹理尺寸**：将纹理的宽度和高度调整为最接近的 2 的幂次方。\\n- **使用纹理参数**：设置纹理参数为 CLAMP_TO_EDGE 和 LINEAR，以支持非 2 的幂次方纹理的渲染\\n\\n我们使用下面三张图片验证一下\\n\\n“F”图像，尺寸：256 \\\\* 256。宽度和高度都是2的整数次幂\\n\\n![image](../../easy-webgl/f.png)\\n\\n“猫”图像，尺寸：640 \\\\* 853。宽度和高度都不是2的整数次幂\\n\\n![image](../../easy-webgl/cat.jpeg)\\n\\n\\\"猫2\\\"图像，尺寸：1024 * 600。宽度为2的整数次幂，高度不是。\\n\\n![image](../../easy-webgl/cat2.jpeg)\\n\\n同时，本篇文章使用下面的Demo演示：\\n\\n\\n```js\\nconst main = (image) => {\\n    const canvas = document.getElementById('webgl')\\n    const gl = canvas.getContext('webgl')\\n    const vertexShaderSource1 = `\\n      attribute vec2 a_texCoord;\\n      attribute vec2 a_position;\\n      varying vec2 v_texCoord;\\n      void main(){\\n          gl_PointSize = 10.0;\\n          gl_Position = vec4(a_position, 0.0, 1.0);\\n          // 将纹理坐标传给片段着色器\\n          // GPU会在点之间进行插值\\n          v_texCoord = a_texCoord;\\n      }\\n    `\\n    const fragmentShaderSource1 = `\\n      precision mediump float;\\n      uniform sampler2D u_image;\\n      // 从顶点着色器传入的纹理坐标\\n      varying vec2 v_texCoord;\\n      void main(){\\n        // 在纹理上寻找对应颜色值\\n        gl_FragColor = texture2D(u_image, v_texCoord);\\n      }\\n    `\\n    const program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1)\\n    const positionLocation1 = gl.getAttribLocation(program1, 'a_position')\\n    const texCoordLocation = gl.getAttribLocation(program1, \\\"a_texCoord\\\");\\n  \\n    // 给矩形提供纹理坐标\\n    const texCoordBuffer = gl.createBuffer();\\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\\n    const x = 1.0, y = 1.0;\\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\\n      0.0, 0.0,\\n      x, 0.0,\\n      0.0, y,\\n      x, 0.0,\\n      0.0, y,\\n      x, y\\n    ]), gl.STATIC_DRAW);\\n    gl.enableVertexAttribArray(texCoordLocation);\\n    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\\n  \\n    // 创建纹理\\n    var texture = gl.createTexture();\\n    gl.bindTexture(gl.TEXTURE_2D, texture);\\n  \\n  \\n    // 将图像上传到纹理\\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\n    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\\n    // gl.generateMipmap(gl.TEXTURE_2D);\\n\\n    const rectX = 0.5, rectY =  0.5;\\n    let verticesInfo = [\\n      0.0, rectY,\\n      rectX, rectY,\\n      0, 0,\\n      rectX, rectY,\\n      0, 0,\\n      rectX, 0,\\n    ]\\n    verticesInfo = new Float32Array(verticesInfo)\\n  \\n    const vertexBuffer = gl.createBuffer();\\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\\n    gl.bufferData(gl.ARRAY_BUFFER, verticesInfo, gl.STATIC_DRAW)\\n  \\n  \\n    gl.vertexAttribPointer(\\n      positionLocation1,\\n      2,\\n      gl.FLOAT,\\n      false,\\n      8,\\n      0\\n    );\\n  \\n  \\n  \\n    gl.clearColor(0, 0, 0, 0.1)\\n  \\n    gl.clear(gl.COLOR_BUFFER_BIT);\\n  \\n    gl.useProgram(program1)\\n  \\n    gl.enableVertexAttribArray(positionLocation1);\\n  \\n    gl.drawArrays(gl.TRIANGLES, 0,6)\\n  \\n  }\\n  \\n  \\n  const image = new Image();\\n  // image.src = \\\"./cat.jpeg\\\";  // 640 * 853\\n  // image.src = \\\"./cat2.jpeg\\\";  // 1024 * 600\\n  // image.src = \\\"./f.png\\\";  // 尺寸：256 * 256\\n\\n  image.onload = function () {\\n    main(image);\\n  }\\n```\\n\\n## 二、纹理尺寸为 2 的整数次幂\\n\\n上面的图像“F”尺寸为 256\\\\*256，为 2 的整数次幂。当纹理尺寸为 2 的整数次幂时，必须要设置下面至少一项\\n- 调用并设置`gl.TEXTURE_MIN_FILTER`为`gl.NEAREST`或者`gl.LINEAR`以关闭纹理映射\\n- 调用`gl.generateMipmap`生成纹理映射，这样webgl就可以选择使用纹理映射绘制\\n\\n修改上面的DEMO，使用图像\\\"F\\\"\\n```js\\n  // image.src = \\\"./cat.jpeg\\\";  // 640 * 853\\n  // image.src = \\\"./cat2.jpeg\\\";  // 1024 * 600\\n  image.src = \\\"./f.png\\\";  // 尺寸：256 * 256\\n```\\n\\n下面的两行注释中，至少有一行是放开的，图像都可以正常绘制\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\n// gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\\n// gl.generateMipmap(gl.TEXTURE_2D);\\n```\\n比如只设置gl.TEXTURE_MIN_FILTER\\n\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\\n// gl.generateMipmap(gl.TEXTURE_2D);\\n```\\n或者只调用generateMipmap\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\n// gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\\ngl.generateMipmap(gl.TEXTURE_2D);\\n```\\n\\n上面几种方式，纹理都可以正常绘制，如下所示：\\n\\n![image](../../easy-webgl/texture_09.jpg)\\n\\n\\n### 2.1 gl.TEXTURE_MIN_FILTER的取值\\ngl.TEXTURE_MIN_FILTER的取值：\\n- NEAREST \\n- LINEAR\\n- NEAREST_MIPMAP_NEAREST\\n- LINEAR_MIPMAP_NEAREST\\n- NEAREST_MIPMAP_LINEAR\\n- LINEAR_MIPMAP_LINEAR\\n\\n如果不调用gl.generateMipmap生成纹理映射，那么gl.TEXTURE_MIN_FILTER只能取值为gl.LINEAR或者gl.NEAREST。下面的代码绘制将出错：\\n\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);\\n// gl.generateMipmap(gl.TEXTURE_2D);\\n```\\n这是因为我们没有调用gl.generateMipmap生成纹理映射，但gl.TEXTURE_MIN_FILTER参数却设置成从纹理映射中选择贴图。在着色器中当 texture2D 被调用的时候由于纹理没有正确设置，就会使用颜色 (0, 0, 0, 1)也就是黑色\\n\\n![image](../../easy-webgl/texture_10.jpg)\\n\\n因此需要调用generateMipmap，下面的代码才能正确绘制纹理。\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);\\ngl.generateMipmap(gl.TEXTURE_2D);\\n```\\n\\n### 2.2 环绕模式\\n在 WebGL 中，如果纹理的尺寸是2的整数次幂，可以自由设置 gl.TEXTURE_WRAP_S 和 gl.TEXTURE_WRAP_T 为 gl.REPEAT、gl.CLAMP_TO_EDGE 或 gl.MIRRORED_REPEAT，比如：\\n\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);\\ngl.generateMipmap(gl.TEXTURE_2D);\\n```\\n\\n## 三、纹理宽和高都不是 2 的整数次幂\\n上面的图像“猫”尺寸为 640 \\\\* 853，宽度和高度都不是 2 的整数次幂。\\n\\n修改上面的DEMO，使用图像\\\"猫\\\"\\n```js\\nimage.src = \\\"./cat.jpeg\\\";  // 640 * 853\\n// image.src = \\\"./cat2.jpeg\\\";  // 1024 * 600\\n// image.src = \\\"./f.png\\\";  // 尺寸：256 * 256\\n```\\n### 3.1 不能使用纹理映射\\n当纹理的宽度和高度都不是2的整数次幂的纹理，不能生成纹理映射，下面的代码绘制将会出错\\n\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.generateMipmap(gl.TEXTURE_2D);\\n```\\n显示纹理失败，在着色器中当 texture2D 被调用的时候由于纹理没有正确设置， 就会使用颜色 (0, 0, 0, 1) 也就是黑色。如果打开 JavaScript 控制台或者浏览器控制台， 根据浏览器不同可能会显示不同的错误信息，像这样\\n\\n![image](../../easy-webgl/texture_11.jpg)\\n\\n### 3.2 如何正确显示\\n如果需要让宽度和高度都不是2的整数次幂的贴图能够正确显示，只需要同时将水平和垂直包裹模式设置为 CLAMP_TO_EDGE 并且通过设置过滤器为 LINEAR or NEAREST 来关闭贴图映射。\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\n```\\n\\n### 3.3 环绕模式\\n在 WebGL 中，如果纹理的宽度和高度 不是 2 的整数次幂（即非幂次方纹理），默认情况下 无法 将 gl.TEXTURE_WRAP_S 和 gl.TEXTURE_WRAP_T 设置为 gl.REPEAT或者gl.MIRRORED_REPEAT。这是因为 WebGL 对于非幂次方纹理的环绕模式有严格的限制。\\n\\n对于非2的整数次幂方纹理，gl.TEXTURE_WRAP_S 和 gl.TEXTURE_WRAP_T 的取值只能是 gl.CLAMP_TO_EDGE。下面的代码可以正常绘制：\\n\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\n```\\n\\n如果尝试设置为 gl.REPEAT 或 gl.MIRRORED_REPEAT，WebGL 会抛出错误（例如，INVALID_OPERATION，有些浏览器可能不会抛出错误，但会绘制黑色的背景）\\n\\n下面的代码显示纹理失败，在着色器中当 texture2D 被调用的时候由于纹理没有正确设置， 就会使用颜色 (0, 0, 0, 1) 也就是黑色\\n\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\n```\\n\\n![image](../../easy-webgl/texture_12.jpg)\\n\\n\\n## 四、纹理宽度和高度其中之一是2的整数次幂\\n当纹理的宽度和高度其中之一是2的整数次幂，比如下面的场景之一：\\n- 宽度为2的整数次幂，高度不是。\\n- 或者宽度不是2的整数次幂，高度是。\\n\\n以上两种场景，在环绕模式的设置会有些差异。\\n\\n上面的图像“猫2”尺寸为 1024 * 600，宽度是2的整数次幂，而高度不是。\\n\\n修改上面的DEMO，使用图像\\\"猫2\\\"\\n```js\\n// image.src = \\\"./cat.jpeg\\\";  // 640 * 853\\nimage.src = \\\"./cat2.jpeg\\\";  // 1024 * 600\\n// image.src = \\\"./f.png\\\";  // 尺寸：256 * 256\\n```\\n\\n### 4.1不能使用纹理映射\\n实际上，只要纹理有一个尺寸不是2的整数次幂，都不能使用纹理映射，下面的代码将绘制出错。\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.generateMipmap(gl.TEXTURE_2D);\\n```\\n\\n纹理不能正常显示，如下所示：\\n\\n![image](../../easy-webgl/texture_11.jpg)\\n\\n\\n### 4.2如何正确显示\\n需要将gl.gl.TEXTURE_MIN_FILTER设置为gl.LINEAR或者gl.NEAREST以关闭纹理映射，同时需要将垂直方向的环绕模式gl.TEXTURE_WRAP_T设置为gl.CLAMP_TO_EDGE。以下代码可以正常绘制：\\n\\n```js\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); // 垂直方向\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\n```\\n\\n\\n### 4.3 环绕模式\\n为2的整数幂的那一边，可以自由设置为\\n\\n- 宽度为2的整数次幂，高度不是。此时gl.TEXTURE_WRAP_S可以取gl.CLAMP_TO_EDGE、gl.REPEAT或者gl.MIRRORED_REPEAT之一，但gl.TEXTURE_WRAP_T只能取值gl.CLAMP_TO_EDGE\\n- 或者宽度不是2的整数次幂，高度是。此时gl.TEXTURE_WRAP_T可以取gl.CLAMP_TO_EDGE、gl.REPEAT或者gl.MIRRORED_REPEAT之一，但gl.TEXTURE_WRAP_S只能取值gl.CLAMP_TO_EDGE\\n\\n比如下面的代码可以正常绘制\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT); // 水平方向\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\n```\\n\\n## 如何绘制所有尺寸的图像\\n下面的代码可以正常绘制所有尺寸的纹理，这里为了方便直观的看到不同尺寸下，纹理参数如何正确设置，所以使用if else穷举了各种尺寸场景。\\n```js\\nfunction isPowerOf2(value) {\\n    return (value & (value - 1)) === 0;\\n}\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\n// 检查每个维度是否是 2 的幂\\nif (isPowerOf2(image.width) && isPowerOf2(image.height)) {\\n    // 宽度和高度都是 2 的幂，一般用纹理映射中的贴图\\n    gl.generateMipmap(gl.TEXTURE_2D);\\n    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST); // 可以自由设置，也可以不设置\\n} else if(!isPowerOf2(image.width) && !isPowerOf2(image.height)){\\n    // 宽度和高度都不是 2 的幂，关闭纹理映射贴图并设置水平和垂直方向的环绕模式为到gl.CLAMP_TO_EDGE\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); \\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); // 关闭纹理映射贴图，只能取值gl.LINEAR或者gl.NEAREST\\n} else if(!isPowerOf2(image.width) && isPowerOf2(image.height)){\\n    // 宽度不是 2 的幂，高度是，关闭纹理映射贴图并设置水平方向环绕模式为到gl.CLAMP_TO_EDGE\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); // 水平方向环绕模式只能设置成gl.CLAMP_TO_EDGE\\n    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); // 垂直方向的环绕模式可以自由设置，也可以不设置\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); // 关闭纹理映射贴图，只能取值gl.LINEAR或者gl.NEAREST\\n} else if(isPowerOf2(image.width) && !isPowerOf2(image.height)){\\n    // 宽度是 2 的幂，高度不是，关闭纹理映射贴图并设置垂直方向环绕模式为到gl.CLAMP_TO_EDGE\\n    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); // 水平方向的环绕模式可以自由设置，也可以不设置\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); // 垂直方向环绕模式只能设置成gl.CLAMP_TO_EDGE\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); // 关闭纹理映射贴图，只能取值gl.LINEAR或者gl.NEAREST\\n}\\n```\\n\\n当然也可以这么写：\\n\\n```js\\nfunction isPowerOf2(value) {\\n    return (value & (value - 1)) === 0;\\n}\\n    \\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\n// 检查每个维度是否是 2 的幂\\nif (isPowerOf2(image.width) && isPowerOf2(image.height)) {\\n    // 宽度和高度都是 2 的幂，一般用贴图\\n    gl.generateMipmap(gl.TEXTURE_2D);\\n } else {\\n    // 宽度或者高度只要有一个不是 2 的幂，关闭贴图并设置包裹模式为到边缘\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\\n }\\n```\"} />;\n  }\n  \n  export default Index;"],"names":["_jsx","MarkDown","srcDoc"],"sourceRoot":""}