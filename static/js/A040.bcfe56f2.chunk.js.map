{"version":3,"file":"static/js/A040.bcfe56f2.chunk.js","mappings":"0JAOE,QAJA,WACE,OAAOA,EAAAA,EAAAA,KAACC,EAAAA,EAAQ,CAACC,OAAQ,qhYAC3B,C","sources":["dynamic/pages/纹理/纹理尺寸.jsx"],"sourcesContent":["import React from \"react\";\n  import MarkDown from \"@/components/markdown\";\n  \n  function Index() {\n    return <MarkDown srcDoc={\"## 纹理尺寸\\n\\nWebGL 对纹理维度的限制主要源于其基于 OpenGL ES 2.0 规范，该规范要求纹理的宽度和高度必须是 2 的整数次幂（如 1x1, 2x2, 4x4, 8x8 等）。这一限制影响了纹理的渲染和性能。\\n\\n### 限制的原因\\n\\n- **性能优化**：2 的幂次方纹理可以更高效地使用硬件加速，提高渲染性能。\\n- **纹理过滤和 mipmap 生成**：2 的幂次方纹理支持更高质量的纹理过滤和 mipmap 生成，提升图像质量。\\n\\n### 如何处理非 2 的幂次方纹理\\n\\n- **调整纹理尺寸**：将纹理的宽度和高度调整为最接近的 2 的幂次方。\\n- **使用纹理参数**：设置纹理参数为 CLAMP_TO_EDGE 和 LINEAR，以支持非 2 的幂次方纹理的渲染\\n\\n我们使用下面两张图片验证一下\\n\\n“F”图像，尺寸：256 \\\\* 256。\\n\\n![image](../../easy-webgl/f.png)\\n\\n“猫”图像，尺寸：640 \\\\* 853\\n\\n![image](../../easy-webgl/cat.jpeg)\\n\\n同时，本篇文章使用下面的Demo演示：\\n\\n\\n```js\\nconst main = (image) => {\\n    const canvas = document.getElementById('webgl')\\n    const gl = canvas.getContext('webgl')\\n    const vertexShaderSource1 = `\\n      attribute vec2 a_texCoord;\\n      attribute vec2 a_position;\\n      varying vec2 v_texCoord;\\n      void main(){\\n          gl_PointSize = 10.0;\\n          gl_Position = vec4(a_position, 0.0, 1.0);\\n          // 将纹理坐标传给片段着色器\\n          // GPU会在点之间进行插值\\n          v_texCoord = a_texCoord;\\n      }\\n    `\\n    const fragmentShaderSource1 = `\\n      precision mediump float;\\n      uniform sampler2D u_image;\\n      // 从顶点着色器传入的纹理坐标\\n      varying vec2 v_texCoord;\\n      void main(){\\n        // 在纹理上寻找对应颜色值\\n        gl_FragColor = texture2D(u_image, v_texCoord);\\n      }\\n    `\\n    const program1 = initShaders(gl, vertexShaderSource1, fragmentShaderSource1)\\n    const positionLocation1 = gl.getAttribLocation(program1, 'a_position')\\n    const texCoordLocation = gl.getAttribLocation(program1, \\\"a_texCoord\\\");\\n  \\n    // 给矩形提供纹理坐标\\n    const texCoordBuffer = gl.createBuffer();\\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\\n    const x = 1.0, y = 1.0;\\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\\n      0.0, 0.0,\\n      x, 0.0,\\n      0.0, y,\\n      x, 0.0,\\n      0.0, y,\\n      x, y\\n    ]), gl.STATIC_DRAW);\\n    gl.enableVertexAttribArray(texCoordLocation);\\n    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\\n  \\n    // 创建纹理\\n    var texture = gl.createTexture();\\n    gl.bindTexture(gl.TEXTURE_2D, texture);\\n  \\n  \\n    // 将图像上传到纹理\\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\n    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\\n    // gl.generateMipmap(gl.TEXTURE_2D);\\n\\n    const rectX = 0.5, rectY =  0.5;\\n    let verticesInfo = [\\n      0.0, rectY,\\n      rectX, rectY,\\n      0, 0,\\n      rectX, rectY,\\n      0, 0,\\n      rectX, 0,\\n    ]\\n    verticesInfo = new Float32Array(verticesInfo)\\n  \\n    const vertexBuffer = gl.createBuffer();\\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\\n    gl.bufferData(gl.ARRAY_BUFFER, verticesInfo, gl.STATIC_DRAW)\\n  \\n  \\n    gl.vertexAttribPointer(\\n      positionLocation1,\\n      2,\\n      gl.FLOAT,\\n      false,\\n      8,\\n      0\\n    );\\n  \\n  \\n  \\n    gl.clearColor(0, 0, 0, 0.1)\\n  \\n    gl.clear(gl.COLOR_BUFFER_BIT);\\n  \\n    gl.useProgram(program1)\\n  \\n    gl.enableVertexAttribArray(positionLocation1);\\n  \\n    gl.drawArrays(gl.TRIANGLES, 0,6)\\n  \\n  }\\n  \\n  \\n  const image = new Image();\\n  // image.src = \\\"./cat.jpeg\\\";  // 必须在同一域名下\\n  // image.src = \\\"./f.png\\\";  // 必须在同一域名下\\n\\n  image.onload = function () {\\n    main(image);\\n  }\\n```\\n\\n## 纹理尺寸为 2 的整数次幂\\n\\n上面的图像“F”尺寸为 256\\\\*256，为 2 的整数次幂。当纹理尺寸为 2 的整数次幂时，必须要设置下面至少一项\\n- 调用并设置`gl.TEXTURE_MIN_FILTER`为`gl.NEAREST`或者`gl.LINEAR`\\n- 调用`gl.generateMipmap`生成纹理贴图\\n\\n修改上面的DEMO，使用图像\\\"F\\\"\\n```js\\nconst image = new Image();\\n// image.src = \\\"./cat.jpeg\\\";  // 必须在同一域名下\\nimage.src = \\\"./f.png\\\";  // 必须在同一域名下\\n```\\n\\n下面的两行注释中，至少有一行是放开的，图像都可以正常绘制\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\n// gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\\n// gl.generateMipmap(gl.TEXTURE_2D);\\n```\\n比如只设置gl.TEXTURE_MIN_FILTER\\n\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\\n// gl.generateMipmap(gl.TEXTURE_2D);\\n```\\n或者只调用generateMipmap\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\n// gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\\ngl.generateMipmap(gl.TEXTURE_2D);\\n```\\n\\n上面集中方式，纹理都可以正常绘制，如下所示：\\n\\n![image](../../easy-webgl/texture_09.jpg)\\n\\n\\n### gl.TEXTURE_MIN_FILTER的取值\\ngl.TEXTURE_MIN_FILTER的取值：\\n- NEAREST \\n- LINEAR\\n- NEAREST_MIPMAP_NEAREST\\n- LINEAR_MIPMAP_NEAREST\\n- NEAREST_MIPMAP_LINEAR\\n- LINEAR_MIPMAP_LINEAR\\n\\n如果不调用gl.generateMipmap生成纹理映射，那么gl.TEXTURE_MIN_FILTER只能取值为gl.LINEAR或者gl.NEAREST。下面的代码绘制将出错：\\n\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);\\n// gl.generateMipmap(gl.TEXTURE_2D);\\n```\\n这是因为我们没有调用gl.generateMipmap生成纹理映射，但gl.TEXTURE_MIN_FILTER参数却设置成从纹理映射中选择贴图。在着色器中当 texture2D 被调用的时候由于纹理没有正确设置，就会使用颜色 (0, 0, 0, 1)也就是黑色\\n\\n![image](../../easy-webgl/texture_10.jpg)\\n\\n因此需要调用generateMipmap，下面的代码才能正确绘制纹理。\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);\\ngl.generateMipmap(gl.TEXTURE_2D);\\n```\\n\\n### 环绕模式\\n在 WebGL 中，如果纹理的尺寸是2的整数次幂，可以自由设置 gl.TEXTURE_WRAP_S 和 gl.TEXTURE_WRAP_T 为 gl.REPEAT、gl.CLAMP_TO_EDGE 或 gl.MIRRORED_REPEAT，比如：\\n\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);\\ngl.generateMipmap(gl.TEXTURE_2D);\\n```\\n\\n## 纹理尺寸为非 2 的整数次幂\\n上面的图像“猫”尺寸为 640 \\\\* 853，不是 2 的整数次幂。\\n\\n修改上面的DEMO，使用图像\\\"猫\\\"\\n```js\\nconst image = new Image();\\nimage.src = \\\"./cat.jpeg\\\";  // 必须在同一域名下\\n// image.src = \\\"./f.png\\\";  // 必须在同一域名下\\n```\\n### 不能使用纹理映射\\n非2的整数次幂的纹理，不能生成纹理映射，下面的代码绘制将会出错\\n\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.generateMipmap(gl.TEXTURE_2D);\\n```\\n显示纹理失败，在着色器中当 texture2D 被调用的时候由于纹理没有正确设置， 就会使用颜色 (0, 0, 0, 1) 也就是黑色。如果打开 JavaScript 控制台或者浏览器控制台， 根据浏览器不同可能会显示不同的错误信息，像这样\\n\\n![image](../../easy-webgl/texture_11.jpg)\\n\\n### 如何正确显示\\n如果需要让非2的整数次幂的贴图能够正确显示，只需要将包裹模式设置为 CLAMP_TO_EDGE 并且通过设置过滤器为 LINEAR or NEAREST 来关闭贴图映射。\\n```js\\n// 将图像上传到纹理\\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\n```\\n\\n\\n\\n\\n### 环绕模式\\n在 WebGL 中，如果纹理的宽度和高度 不是 2 的整数次幂（即非幂次方纹理），默认情况下 无法 将 gl.TEXTURE_WRAP_S 和 gl.TEXTURE_WRAP_T 设置为 gl.REPEAT。这是因为 WebGL 对于非幂次方纹理的环绕模式有严格的限制。\\n\\n对于非幂次方纹理，只能 设置 gl.TEXTURE_WRAP_S 和 gl.TEXTURE_WRAP_T 为 gl.CLAMP_TO_EDGE。\\n如果尝试设置为 gl.REPEAT 或 gl.MIRRORED_REPEAT，WebGL 会抛出错误（例如，INVALID_OPERATION）\\n\\n\\n\"} />;\n  }\n  \n  export default Index;"],"names":["_jsx","MarkDown","srcDoc"],"sourceRoot":""}