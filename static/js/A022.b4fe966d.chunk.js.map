{"version":3,"file":"static/js/A022.b4fe966d.chunk.js","mappings":"0JAOE,QAJA,WACE,OAAOA,EAAAA,EAAAA,KAACC,EAAAA,EAAQ,CAACC,OAAQ,42KAC3B,C","sources":["dynamic/pages/基础知识/颜色缓冲区简介.jsx"],"sourcesContent":["import React from \"react\";\n  import MarkDown from \"@/components/markdown\";\n  \n  function Index() {\n    return <MarkDown srcDoc={\"## 颜色缓冲区\\n\\n在 WebGL 渲染管线的最终阶段，经过顶点处理、图元装配、光栅化以及片元处理后，每个片元的颜色值会被写入颜色缓冲区。这些颜色值决定了屏幕上每个像素最终显示的颜色，最终呈现出完整的 3D 场景画面。\\n\\n![image](../../easy-webgl/webgl_render.jpg)\\n\\n如上图，webgl 系统中的绘制操作实际上是在颜色缓冲区中进行绘制的，绘制结束后系统将缓冲区中的内容显示在屏幕上，然后颜色缓冲区就会被重置，其中的内容会丢失。那颜色缓冲区在什么时候会被重置？\\n\\n### Demo1：同步多次调用drawArrays\\n在下面的代码中，我们先后两次调用gl.drawArrays分别在(0.5, 0.0, 0.0)和(0.3, 0.0, 0.0)处绘制两个红色的点。\\n```js\\nconst canvas = document.getElementById('webgl')\\nconst gl = canvas.getContext('webgl')\\n\\nconst vertexShaderSource = `\\n    attribute vec4 a_Position;\\n    void main() {\\n        gl_Position = a_Position;\\n        gl_PointSize = 10.0;\\n    }\\n`;\\n\\nconst fragmentShaderSource = `\\n    precision mediump float;\\n    void main(){\\n        gl_FragColor = vec4(1,0,0,1.0);\\n    }\\n`;\\n\\nconst program = initShaders(gl, vertexShaderSource, fragmentShaderSource);\\ngl.useProgram(program);\\nconst a_Position = gl.getAttribLocation(program, \\\"a_Position\\\");\\ngl.clearColor(0, 0, 0, 1);\\ngl.clear(gl.COLOR_BUFFER_BIT);\\n\\ngl.vertexAttrib3f(a_Position, 0.5, 0.0, 0.0);\\ngl.drawArrays(gl.POINTS, 0, 1);\\n\\ngl.vertexAttrib3f(a_Position, 0.3, 0.0, 0.0);\\ngl.drawArrays(gl.POINTS, 0, 1);\\n```\\n\\n这里，我们同步调用 `drawArrays`，此时页面显示如下：\\n\\n![image](../../easy-webgl/render_01.jpg)\\n\\n\\n### Demo2：先同步后宏任务调用drawArrays\\n在下面的代码中，我们先后调用两次drawArrays方法，然后在定时器中再调用一次。\\n\\n```js\\ngl.clearColor(0, 0, 0, 1);\\ngl.clear(gl.COLOR_BUFFER_BIT);\\n\\ngl.vertexAttrib3f(a_Position, 0.5, 0.0, 0.0);\\ngl.drawArrays(gl.POINTS, 0, 1);\\n\\ngl.vertexAttrib3f(a_Position, 0.3, 0.0, 0.0);\\ngl.drawArrays(gl.POINTS, 0, 1);\\n\\nsetTimeout(() => {\\n  gl.vertexAttrib3f(a_Position, 0.0, 0.5, 0.0);\\n  gl.drawArrays(gl.POINTS, 0, 1);\\n}, 0);\\n```\\n\\n刷新页面，可以看到先显示绘制黑色的背景，黑色背景有两个红色的点。然后立马绘制白色背景，上面只有一个点：\\n\\n![image](../../easy-webgl/render_02.jpg)\\n\\n### Demo3：微任务\\n在下面的代码中，我们先后调用两次drawArrays方法，然后在Promise中再调用一次。\\n\\n\\n```js\\ngl.clearColor(0, 0, 0, 1);\\ngl.clear(gl.COLOR_BUFFER_BIT);\\n\\ngl.vertexAttrib3f(a_Position, 0.5, 0.0, 0.0);\\ngl.drawArrays(gl.POINTS, 0, 1);\\n\\ngl.vertexAttrib3f(a_Position, 0.3, 0.0, 0.0);\\ngl.drawArrays(gl.POINTS, 0, 1);\\n\\nPromise.resolve().then((res) => {\\n  gl.vertexAttrib3f(a_Position, 0.1, 0.0, 0.0);\\n  gl.drawArrays(gl.POINTS, 0, 1);\\n});\\n```\\n\\n刷新页面，可以看到三个点是同时绘制出来的，页面最终效果如下：\\n\\n![image](../../easy-webgl/render_03.jpg)\\n\\n\\n\\n## 小结\\n从上面的示例中，我们可以得出结论，颜色缓冲区大概是在微任务之后，宏任务之前被清空的\\n\\n\\n## 如何手动清除颜色缓冲区？\\n如果需要手动清除颜色缓冲区，可以使用gl.clearColor()函数设置清除颜色，再调用gl.clear(gl.COLOR_BUFFER_BIT)函数，就能将颜色缓冲区的内容全部替换为指定颜色，一般在每次渲染新的一帧画面之前会执行这个操作，以避免之前帧的残留信息影响当前帧的显示。在片元着色器中，通过设置gl_FragColor变量来确定每个片元的颜色值，这些值会被自动写入颜色缓冲区。\\n\\n\"} />;\n  }\n  \n  export default Index;"],"names":["_jsx","MarkDown","srcDoc"],"sourceRoot":""}